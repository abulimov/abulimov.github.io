<!DOCTYPE html>
<html lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8"><meta name="generator" content="Hugo 0.131.0"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><meta name="description" content=""><title>Posts&nbsp;&ndash;&nbsp;Alexander Bulimov: Production Engineer and Scale Modeller</title><link rel="stylesheet" href="/css/core.min.63f706677e61b4ee62b8daf083358d3bbf8ac8ab03c7d171af3180fab3a3ebb83efb79fb98674f13dde6db11de2bf694.css" integrity="sha384-Y/cGZ35htO5iuNrwgzWNO7&#43;KyKsDx9FxrzGA&#43;rOj67g&#43;&#43;3n7mGdPE93m2xHeK/aU"><link rel="alternate" type="application/rss+xml" href="/post/index.xml" title="Alexander Bulimov: Production Engineer and Scale Modeller" /><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Posts" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Alexander Bulimov: Production Engineer and Scale Modeller</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a></nav></div></span></div></section><section id="content"><section class="article header"><h1>Posts</h1></section><ul class="note list"><li class="item">
        
        <a class="note" href="/it/try-packetbeat/">
        
            <p class="note title">Попробуйте Packetbeat</p><p class="note date">2015-05-28</p><p class="note content">Вчера в блоге Elasticsearch появилась отличная новость - проект Packetbeat, развиваемый до этого энтузиастами, присоединился к Elastic.
Я уже довольно давно слежу за этим проектом, и теперь, когда можно не беспокоиться о его будущем, хочу о нем рассказать.
Packetbeat это такой инструмент мониторинга, который работает как анализатор сетевых пакетов, парсит различные протоколы (сейчас поддерживаются HTTP, MySQL, PostgreSQL, Redis, Thrift-RPC), получает нужные данные, и отсылает их либо напрямую в Elasticsearch, либо в Redis, из которого данные будет забирать Logstash и класть их все в тот же Elasticsearch.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/it/">IT</a><a class="category" href="/categories/russian/">Russian</a><a class="tag" href="/tags/packetbeat/">Packetbeat</a><a class="tag" href="/tags/elasticsearch/">Elasticsearch</a><a class="tag" href="/tags/kibana/">Kibana</a><a class="tag" href="/tags/monitoring/">Monitoring</a></p></li><li class="item">
        
        <a class="note" href="/it/vim-atom/">
        
            <p class="note title">Сменил Vim на Atom</p><p class="note date">2015-05-21</p><p class="note content">Вот уже почти два месяца, как я по совету коллеги сменил Vim, которым пользовался уже 5 лет, и который оброс у меня кучей плагинов, на Github Atom.
Использую я его как раньше Vim - для всего. В основном это написание плейбуков Ansible, что включает в себя правку конфигов, и написание кода на Python и Go.
Сразу скажу, что не будь для Atom вменяемого vim-режима, я бы вряд ли решился на переход.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/it/">IT</a><a class="category" href="/categories/russian/">Russian</a><a class="tag" href="/tags/vim/">Vim</a><a class="tag" href="/tags/atom/">Atom</a><a class="tag" href="/tags/%D0%B6%D0%B8%D0%B7%D0%BD%D1%8C/">Жизнь</a></p></li><li class="item">
        
        <a class="note" href="/it/cadvisor-companion/">
        
            <p class="note title">Улучшаем сообщения от мониторинга с помощью cAdvisor-companion</p><p class="note date">2015-04-21</p><p class="note content">Слышали ли вы когда-нибудь о такой практике, как &ldquo;Monitoring Events Enrichment&rdquo;? Если вкратце, то это практика наполнения дополнительной информацией сообщений от мониторинга, так что на выяснение причины проблемы уходит меньше времени и телодвижений.
Есть даже контора, которая помогает внедрять эту практику на коммерческой основе, у них на сайте есть неплохие примеры того, что и зачем можно добавить к обычному сообщению от Nagios.
Сама эта идея мне очень нравится, и вот после очередного неинформативного сообщения от мониторинга, которое пришло тогда, когда я был далеко от компьютера, и гласило CheckDockerStats CRITICAL: 91% CPU Used!<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/it/">IT</a><a class="category" href="/categories/russian/">Russian</a><a class="tag" href="/tags/golang/">Golang</a><a class="tag" href="/tags/cadvisor/">cAdvisor</a><a class="tag" href="/tags/cadvisor-companion/">cAdvisor-companion</a><a class="tag" href="/tags/%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">Программирование</a><a class="tag" href="/tags/monitoring/">Monitoring</a></p></li><li class="item">
        
        <a class="note" href="/it/haproxy-cadvisor/">
        
            <p class="note title">Балансировка в HAProxy на основе данных cAdvisor</p><p class="note date">2015-04-15</p><p class="note content">Для запуска Docker-контейнеров у меня в данный момент выделено достаточно много серверов, причем аппаратная часть у некоторых из них отличается друг от друга. Соответственно, при настройке на чудесном балансировщике HAProxy такого параметра балансировки как &ldquo;вес сервера&rdquo;, приходится это различие в аппаратной части учитывать.
Можно, конечно, подобрать значения весов самостоятельно на основе данных мониторинга, а при появлении нагрузки от соседних Docker-контейнеров эти веса корректировать, но это не наш метод.
Не так давно я писал о том, как использую данные из cAdvisor для мониторинга нагруженности контейнеров.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/it/">IT</a><a class="category" href="/categories/russian/">Russian</a><a class="tag" href="/tags/haproxy/">HAProxy</a><a class="tag" href="/tags/cadvisor/">cAdvisor</a><a class="tag" href="/tags/python/">Python</a><a class="tag" href="/tags/%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">Программирование</a></p></li><li class="item">
        
        <a class="note" href="/it/chromium-vim/">
        
            <p class="note title">Открыл для себя cVim для Google Chrome</p><p class="note date">2015-02-27</p><p class="note content">Последние 4 года я использую Vim в качестве текстового редактора и IDE, и все это время я использовал браузер Mozilla Firefox с дополнением Vimperator, либо с его форком - Pentadactyl, для получения аналогичной навигации в браузере. Без функционала этих дополнений я как без рук, и потому никак не мог использовать Google Chrome/Chromium.
Дополнения типа Vimium/Vrome/ViChrome, которые добавляют vi-like навигацию в Chrome, после Vimperator казались, мягко говоря, недоделанными, и не давали и половины того комфорта при использовании браузера, к которому я привык.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/it/">IT</a><a class="category" href="/categories/russian/">Russian</a><a class="tag" href="/tags/%D0%B6%D0%B8%D0%B7%D0%BD%D1%8C/">Жизнь</a><a class="tag" href="/tags/vim/">Vim</a></p></li><li class="item">
        
        <a class="note" href="/it/check-cadvisor/">
        
            <p class="note title">Мониторим Docker-контейнеры с cAdvisor и Nagios/Icinga2</p><p class="note date">2015-02-20</p><p class="note content">После того, как я научился мониторить память в Docker-контейнерах, я решил мониторить еще и нагрузку на CPU. Поскольку это дело не самое тривиальное, и хотелось не писать свой велосипед, а пользоваться чем-то популярным и поддерживаемым, я решил попробовать cAdvisor.
И вот что я могу сказать - отличный инструмент! Ресурсов практически не потребляет (около 20 Мб оперативной памяти и неизмеримо мало CPU), обладает простым API для доступа к собираемой им информации, имеет красивый веб-интерфейс с realtime-графиками.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/it/">IT</a><a class="category" href="/categories/russian/">Russian</a><a class="tag" href="/tags/python/">Python</a><a class="tag" href="/tags/nagios/">Nagios</a><a class="tag" href="/tags/icinga2/">Icinga2</a><a class="tag" href="/tags/cadvisor/">cAdvisor</a><a class="tag" href="/tags/monitoring/">Monitoring</a></p></li><li class="item">
        
        <a class="note" href="/it/check-docker-memory/">
        
            <p class="note title">Научился мониторить использование памяти в Docker-контейнерах</p><p class="note date">2015-02-13</p><p class="note content">Я сегодня занимался мониторингом, а конкретно нашими докер-контейнерами.
Лирическое отступление: Для мониторинга я теперь (уже на другом месте работы) использую наследника Nagios - Icinga2. Пока все нравится, ребята очень круто переписали Nagios, реализовали гораздо более вменяемый формат конфигурации, и кучу новых возможностей.
Используя Docker для автотестов я уже ловил проблемы, когда интерпретатор Ruby кушал всю выделенную память в контейнере и тихо умирал от рук OOM Killer.
Поскольку теперь я использую Docker уже не только для тестов, но и &ldquo;в бою&rdquo;, меня сильно беспокоило то, что мы не можем мониторить использование памяти внутри контейнера.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/it/">IT</a><a class="category" href="/categories/russian/">Russian</a><a class="tag" href="/tags/python/">Python</a><a class="tag" href="/tags/nagios/">Nagios</a><a class="tag" href="/tags/icinga2/">Icinga2</a><a class="tag" href="/tags/monitoring/">Monitoring</a></p></li><li class="item">
        
        <a class="note" href="/it/lyricstagger/">
        
            <p class="note title">Lyrics Tagger</p><p class="note date">2014-11-25</p><p class="note content">Предыстория Я езжу на работу в общественном транспорте, и слушаю там музыку со смартфона. Достаточно часто хотелось почитать тексты прослушиваемых в данный момент песен, но искать их в интернете было не слишком удобно, да и вообще интернета до недавнего времени в метро не было.
Решение выглядит очевидным - надо встроить тексты песен в сами музыкальные файлы. Благо, основные форматы это позволяют. Музыку я храню во FLAC, а на смартфон закидываю в Ogg Vorbis.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/it/">IT</a><a class="category" href="/categories/russian/">Russian</a><a class="tag" href="/tags/python/">Python</a><a class="tag" href="/tags/%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">Программирование</a></p></li><li class="item">
        
        <a class="note" href="/it/ansible-sensu/">
        
            <p class="note title">Удобная настройка Sensu с Ansible</p><p class="note date">2014-11-13</p><p class="note content">Так как я использую Sensu для мониторинга, и Ansible для управления конфигурациями, то конечно же я настраиваю Sensu с помощью Ansible.
В этой связке меня смущало только одно - Sensu использует JSON для конфигов, в то время как Ansible использует YAML. Поскольку JSON является подмножеством YAML, и описывать конфигурации в YAML гораздо проще (никаких проблем с запятыми, скобочками), хотелось писать в YAML и транслировать в JSON.
Начал я, конечно, с использования шаблонов Ansible:<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/it/">IT</a><a class="category" href="/categories/russian/">Russian</a><a class="tag" href="/tags/ansible/">Ansible</a><a class="tag" href="/tags/sensu/">Sensu</a><a class="tag" href="/tags/monitoring/">Monitoring</a></p></li><li class="item">
        
        <a class="note" href="/it/meminfo-visualizer/">
        
            <p class="note title">Разбирался с page-cache в Linux</p><p class="note date">2014-10-09</p><p class="note content">Читая книгу &ldquo;Разработка ядра Linux&rdquo; за авторством Роберта Лава, я решил поглубже разобраться в том, как работает кэш в Linux, и набрел на вот эту статью на Хабре от Яндекса.
Сама статья весьма познавательна, особенно видео - рекомендую. Так вот, в этом видео Роман Гущин, с помощью простой утилиты, наглядно показывающей размер кэша, показывал как работает файловый кэш.
Конечно, мне захотелось в образовательных целях написать такую утилиту для себя, чтобы можно было поиграться с кэшем и видеть изменения.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="category" href="/categories/it/">IT</a><a class="category" href="/categories/russian/">Russian</a><a class="tag" href="/tags/kernel/">Kernel</a><a class="tag" href="/tags/python/">Python</a><a class="tag" href="/tags/%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">Программирование</a><a class="tag" href="/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/">Книги</a></p></li></ul><div class="pagination">
    <ul><li><a href="/post/page/5/"><span class="iconfont icon-pagepreview"></span></a></li><li><a class="active" href="/post/page/6/">6</a></li><li><a class="" href="/post/page/7/">7</a></li><li><a class="" href="/post/page/8/">8</a></li><li><a class="" href="/post/page/9/">9</a></li></ul>
</div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">Alexander Bulimov: Production Engineer and Scale Modeller</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div></section>
  

</body>

</html>