<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Snooping on unix domain sockets traffic | Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="https://models.bulimov.me">Scale Models</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/reviews/">Reviews</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Snooping on unix domain sockets traffic</span></h1>

<h2 class="date">2021/12/02</h2>

</div>

<main>
<p>I often work with various binary protocol, with majority of work being implementing those protocols in Go or Rust.</p>
<p>And when dealing with such tasks, I find it extremely useful to be able to snoop on
the traffic between existing/reference implementations.</p>
<p>When communication happens over network (even locally), it&rsquo;s easy - just fire up some
good old <code>tcpdump</code> and then maybe analyze the dump with Wireshark.</p>
<p>But what if communication happens over the <a href="https://man7.org/linux/man-pages/man7/unix.7.html">Unix domain sockets</a>?</p>
<p>Then things become tricky, especially if we want to capture this traffic passively.</p>
<h2 id="available-solutions">Available solutions</h2>
<p>Let&rsquo;s explore the options we have, starting from simplest ones.</p>
<h3 id="reconfigure-the-reference-implementation-to-use-network">Reconfigure the reference implementation to use network</h3>
<p>Of course, the easiest approach would be to just tell the app to use network instead of Unix socket.
If there is a flag/config option to do so - great, we are done here!</p>
<p>But often the software deliberately makes some things accessible only over the Unix sockets, mostly for security reasons.</p>
<p>For example, <a href="https://chrony.tuxfamily.org/">chrony</a> NTP daemon allows certain management protocol packets only over the Unix socket,
which has permissions set in a way that unprivileged user won&rsquo;t even be able to access it.</p>
<h3 id="socat">socat</h3>
<p>It&rsquo;s often possible to have <code>socat</code> set up the socket and dump everything that gets sent to it, or redirect it to network.</p>
<p>For example, here is what might be used to snoop on some process and send it&rsquo;s traffic to network, where it could be dumped by <code>tpcdump</code>.</p>
<pre tabindex="0"><code>sudo socat -v UNIX-LISTEN:/path/to/some.sock,fork TCP-CONNECT:127.0.0.1:8090
</code></pre><p>However, this action is disruptive to the running processes, and I personally never had success with this approach.</p>
<h3 id="strace">strace</h3>
<p>It is of course possible to see what is being sent to the socket using any form of syscall tracing.
In fact, that was my go-to approach before I did my research and found better ways to do it.</p>
<p>Here is how one can see what <code>chronyc</code> sends to <code>chronyd</code> over the socket when asked for &rsquo;ntpdata'</p>
<pre tabindex="0"><code>&gt; sudo strace -xx -e sendto,recvfrom -v -s 10000 chronyc ntpdata
sendto(3, &#34;\x06\x01\x00\x00\x00\x0e\x00\x00\x02\x48\x5c\x29\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#34;, 32, 0, NULL, 0) = 32
...
</code></pre><p>Again, the problem here is that it&rsquo;s disruptive and requires changing how the reference app is being run.
And of course if the app does more communication with same syscall, like <code>sendto</code> in chronyc example -
we&rsquo;ll have to sift through all of the messages based on file descriptors.</p>
<p>So this approach works well enough, but we can do better!</p>
<h3 id="bpftrace">bpftrace</h3>
<p>Now we are getting to the truly passive solutions (although they are Linux-specific),
thanks to the amazing power of <a href="https://www.kernel.org/doc/html/latest/bpf/index.html">BPF</a>.</p>
<p>For example, we can snoop on same <code>sendto</code> syscall via <code>bpftrace</code>, which uses BPF with kernel tracepoints:</p>
<pre tabindex="0"><code>&gt; sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_sendto /comm == &#34;chronyc&#34;/ {printf(&#34;%r\n&#34;, buf(args-&gt;buff, args-&gt;len));}&#39;
\x06\x01\x00\x00\x00\x0e\x00\x00\x02\x48\x5c\x29\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
...
</code></pre><p>This is pretty neat, but we still need to know exactly what syscall is used to send data over the socket.</p>
<h3 id="sockdumppy">sockdump.py</h3>
<p>Finally, if we dig more into how the Unix sockets are done in Linux kernel, we can hook <em>kprobe</em> to kernel
functions like <code>unix_stream_sendmsg</code> and capture everything regardless of the method the app uses to send data to the socket.</p>
<p>This is exactly what nifty script called <a href="https://github.com/mechpen/sockdump"><code>sockdump</code></a> does under the hood!</p>
<p>I find this tool extremely useful, and recently <a href="https://github.com/mechpen/sockdump/pull/8">contributed to it</a>
support for DGRAM sockets and dumping data in escaped hex string format,
which can be then used directly in Go or Python as for example an input for unittests.</p>
<p>Here is how it looks like for <code>pmc</code> talking to <code>ptp4l</code> (both are part of <a href="http://linuxptp.sourceforge.net">linuxptp</a> project):</p>
<pre tabindex="0"><code>$ sudo ./sockdump.py &#39;/var/run/p*&#39; --format hexstring
waiting for data
10:11:28.968 &gt;&gt;&gt; process pmc [1108317 -&gt; 0] len 74(74)
\x0d\x12\x00\x4a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe9\x5d\x00\x00\x04\x7f\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x01\x00\x16\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
10:11:28.968 &gt;&gt;&gt; process ptp4l [896569 -&gt; 0] len 74(74)
\x0d\x12\x00\x4a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x48\x57\xdd\xff\xfe\x07\x93\x21\x00\x00\x00\x00\x04\x7f\x00\x00\x00\x00\x00\x00\x00\x00\xe9\x5d\x00\x00\x02\x00\x00\x01\x00\x16\x20\x00\x01\x00\x00\x01\x80\xf8\xfe\xff\xff\x80\x48\x57\xdd\xff\xfe\x07\x93\x21\x00\x00
^C
2 packets captured
</code></pre><p>Also, if one is being curious - now it supports prefix-based socket path matching, and specifying &lsquo;*&rsquo; as a socket path
allows to dump <strong>all</strong> the communications happening over Unix sockets on the system.
Spoiler alert: <em>systemd</em> does a lot of stuff there.</p>
<h2 id="use-case">Use-case</h2>
<p>All and all, I find the ability to dump communication happening over Unix Domain sockets to be very useful.</p>
<p>First, it&rsquo;s extremely valuable to record the interactions that happen over Unix sockets to be able to implement
intricate details of the (often undocumented) protocols.</p>
<p>For example, protocol used for <em>chronyd &lt;-&gt; chronyc</em> communication is completely undocumented, so in order to <a href="https://github.com/facebookincubator/ntp/tree/main/protocol/chrony">implement
it in Go</a> I had exactly two options - reading the C source code and looking at the live traffic.</p>
<p>Without the ability to see what&rsquo;s going on over the socket,
it would have been very hard to implement parts of the protocol that are not allowed to be used over the network.</p>
<p>And second, once code works, it&rsquo;s easy to collect data for extensive unittests with a tool like <code>sockdump.py</code>.
You just fire up the script, perform various actions with commands that communicate over the socket,
and use collected dumps as fixtures/data for table-driven tests.</p>
<p>So while this is not something that most of the IT folks will use every day, for me it&rsquo;s a very useful tool in my toolbox,
and I use it fairly regularly.</p>
<p>And if you are interested to learn more about BPF that powers <code>sockdump.py</code> and <code>bpftrace</code>, I can highly recommend the wonderful
<a href="https://www.brendangregg.com/bpf-performance-tools-book.html"><strong>BPF Performance Tools</strong></a> book by Brendan Gregg.</p>

</main>


<p class="terms">
<b>Tags:</b>

  <a href="//bulimov.me/tags/bpf/">BPF</a>

  <a href="//bulimov.me/tags/linux/">Linux</a>

  <a href="//bulimov.me/tags/python/">Python</a>


</p>
<p class="terms">

<b>Categories:</b>

  <a href="//bulimov.me/categories/it/">IT</a>


</p>

  <footer>
  
  
  <hr/>
  <a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" alt="License: CC BY-SA 4.0"></a> Â© <a href="http://bulimov.me">Alexander Bulimov</a> 2013 &ndash; 2025 | <a href="https://github.com/abulimov">Github</a>
  
  </footer>
  </body>
</html>

