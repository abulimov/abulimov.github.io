<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Logstash и Graphite | Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="https://models.bulimov.ru">Scale Models</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/reviews/">Reviews</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Logstash и Graphite</span></h1>

<h2 class="date">2015/10/09</h2>

</div>

<main>
<p>Недавно читал серию постов от <a href="https://www.datadoghq.com">Datadog</a> про сбор метрик,
и в частности <a href="https://www.datadoghq.com/blog/how-to-collect-nginx-metrics/">статью про метрики Nginx</a>
(думал, вдруг что-то новое узнаю). Что меня в этой статье зацепило - так это то, что только версия
<a href="https://www.nginx.com/products/">Nginx Plus</a> показывает статистику количества
ответов, разделенную по HTTP-кодам. Поскольку я использую перед Nginx балансировщик
<a href="http://www.haproxy.org">HAProxy</a>, который не жадный и показывает подробную статистику
по кодам ответов для каждого бекенда и фронтенда, я о таком минусе статистики Nginx даже не думал.</p>
<p>Поскольку я совсем недавно решал схожую задачу получения метрик от сервиса,
который сам эти метрики не отдает, решил поделиться достаточно универсальным рецептом,
который поможет, к примеру, получать от обычного Nginx подробную статистику по
кодам ответов.</p>
<p><em>Это, на мой взгляд, очень нужная метрика. А то бывает, что сервис твой работает,
мониторинг доволен, а некий процент запросов незаметно падает с 50x ошибками. И вроде бы
можно смотреть в логи в той же Kibana, но не будешь же это делать каждый день.</em></p>
<p>###Простой и полезный пример получения метрик из логов</p>
<p>Итак, для приготовления вкусных метрик нам понадобится:</p>
<ul>
<li>Некий сервис, который умеет писать логи в любом вменяемом формате, содержащем
интересующие нас метрики. Для примера возьмем обычный Nginx;</li>
<li>Универсальный комбайн по обработке логов - <a href="https://www.elastic.co/products/logstash">Logstash</a>;</li>
<li>Агрегатор метрик - <a href="https://github.com/etsy/statsd">StatsD</a>;</li>
<li>Наконец, сервис хранения метрик - <a href="http://graphite.readthedocs.org/en/latest/">Graphite</a>.</li>
</ul>
<p>Итак, мы хотим знать, сколько же и каких мы отдаем бедным пользователям HTTP-ответов.
Nginx пишет по-умолчанию access-log в формате <em>combined</em>, который определен так:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span><span style="color:#66d9ef">log_format</span> <span style="color:#e6db74">combined</span> <span style="color:#e6db74">&#39;</span>$remote_addr <span style="color:#e6db74">-</span> $remote_user <span style="color:#e6db74">[</span>$time_local] <span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#39;&#34;</span>$request&#34; $status $body_bytes_sent <span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#39;&#34;</span>$http_referer&#34; <span style="color:#e6db74">&#34;</span>$http_user_agent&#34;&#39;;
</span></span></code></pre></div><p>Для нас это отлично, поскольку</p>
<ol>
<li>этот формат совместим с логом Apache2,</li>
<li>в этом логе есть нужные нам данные - $status.</li>
</ol>
<p>Первый пункт радует тем, что не надо писать своих grok-паттернов для Logstash.
Хотя при знании регулярных выражений это и не сложно, всегда лучше взять готовое.</p>
<p>Нужный нам паттерн называется <strong>COMBINEDAPACHELOG</strong>, актуальную версию можно посмотреть
в <a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns">репозитории Logstash-plugins</a>,
на момент написания этой статьи он выглядел так:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#66d9ef">COMMONAPACHELOG</span> <span style="color:#e6db74">%{IPORHOST:clientip}</span> <span style="color:#e6db74">%{HTTPDUSER:ident}</span> <span style="color:#e6db74">%{USER:auth}</span> \<span style="color:#f92672">[</span><span style="color:#e6db74">%{HTTPDATE:timestamp}</span>\<span style="color:#f92672">]</span> <span style="color:#e6db74">&#34;(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})&#34;</span> <span style="color:#e6db74">%{NUMBER:response}</span> (<span style="color:#e6db74">?:</span><span style="color:#e6db74">%{NUMBER:bytes}</span><span style="color:#f92672">|-</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">COMBINEDAPACHELOG</span> <span style="color:#e6db74">%{COMMONAPACHELOG}</span> <span style="color:#e6db74">%{QS:referrer}</span> <span style="color:#e6db74">%{QS:agent}</span>
</span></span></code></pre></div><p><em>Кстати, в документации к плагину grok указана ссылка на <a href="http://grokdebug.herokuapp.com">отличный онлайн-инструмент</a>
для проверки grok-паттернов.</em></p>
<p>Как мы видим, интересующая нас переменная зовется в Logstash <strong>response</strong>, так что
теперь мы можем спокойно писать конфиг для отправки этой метрики в StatsD-&gt;Graphite.
Предположим, мы принимаем логи от Nginx по протоколу syslog (Nginx уже довольно давно
умеет слать логи напрямую в syslog, и это очень удобно).</p>
<p><strong>пример конфига для парсинга метрик из логов Nginx</strong></p>
<pre tabindex="0"><code class="language-logstash" data-lang="logstash">input {
  syslog {
    port =&gt; 5014
    type =&gt; &#34;syslog&#34;
  }
}
filter {
  if [program] == &#34;nginx&#34; {
    grok {
      match =&gt; {
        message =&gt; &#39;%{COMBINEDAPACHELOG}&#39;
      }
    }
}
output {
  if [type] == &#34;syslog&#34; {
    if [program] == &#34;nginx&#34; {
      # отправим в StatsD количество переданных байт
      statsd {
        host =&gt; &#39;graphite.example.com&#39;
        count =&gt; [ &#34;nginx.response_%{response}.bytes&#34;, &#34;%{bytes}&#34; ]
        sender =&gt; &#34;%{logsource}&#34;
      }
      # увеличим в StatsD счетчик ответов с конкретным кодом
      statsd {
        host =&gt; &#39;graphite.example.com&#39;
        increment =&gt; &#34;nginx.response_%{response}&#34;
        sender =&gt; &#34;%{logsource}&#34;
      }
    }
    # тут сохраняем логи в elasticsearch, или еще что-то полезное делаем с логами
  }
}
</code></pre><p>Вот и все, открываем <a href="http://grafana.org/">Grafana</a> и наслаждаемся вкусными
метриками, без всякого Nginx Plus.</p>
<h4 id="мало-кому-полезный-пример-из-личного-опыта">Мало кому полезный пример из личного опыта</h4>
<p>Я решал другую, более специфичную и немного более сложную задачу - получение
времени ответа, количества запросов, переданного объема данных с зависимостью от
статуса попадания в кеш в продвинутом кешируещем
сервере <a href="http://trafficserver.apache.org">Apache Traffic Server</a>.</p>
<p>Тут пришлось чуть больше поработать:</p>
<ul>
<li>Написать свой grok-паттерн для парсинга логов ATS</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#66d9ef">TRAFFICSERVER_ACCESS</span> <span style="color:#e6db74">%{NUMBER:ats_timestamp}</span>\s<span style="color:#f92672">+</span><span style="color:#e6db74">%{NUMBER:request_msec:int}</span> <span style="color:#e6db74">%{IPORHOST:client_ip}</span> <span style="color:#e6db74">%{WORD:cache_result}</span><span style="color:#f92672">/</span><span style="color:#e6db74">%{NUMBER:http_status_code:int}</span> <span style="color:#e6db74">%{NUMBER:bytes_read:int}</span> <span style="color:#e6db74">%{WORD:http_verb}</span> (<span style="color:#e6db74">%{URIPROTO:http_proto}</span><span style="color:#e6db74">:/</span><span style="color:#f92672">/</span>)<span style="color:#e6db74">?%</span>{<span style="color:#e6db74">IPORHOST</span>:dst_host}(<span style="color:#e6db74">?:</span><span style="color:#e6db74">:%</span>{<span style="color:#e6db74">POSINT</span>:<span style="color:#e6db74">port</span>:int})<span style="color:#e6db74">?(?:</span><span style="color:#e6db74">%{URIPATHPARAM:http_request}</span>)? <span style="color:#e6db74">%{DATA:cache_user}</span> <span style="color:#e6db74">%{WORD:request_route}</span><span style="color:#f92672">/</span>(<span style="color:#e6db74">%{IPORHOST:forwarded_to}</span><span style="color:#f92672">|-</span>) <span style="color:#e6db74">%{GREEDYDATA:content_type}</span>
</span></span></code></pre></div><ul>
<li>Научить rsyslog тейлить и слать логи ATS в Logstash</li>
</ul>
<pre tabindex="0"><code>$MaxMessageSize 32k
$ModLoad imfile

$InputFileName /var/log/trafficserver/squid.log
$InputFileTag trafficserver-access:
$InputFileStateFile trafficserver-access
$InputFileFacility local4
$InputFileSeverity info
$InputRunFileMonitor

local4.* @log.example.com:5014
&amp; ~
</code></pre><ul>
<li>Написать конфиг Logstash для отправки полученных метрик в StatsD</li>
</ul>
<pre tabindex="0"><code>input {
  syslog {
    port =&gt; 5014
    type =&gt; &#34;syslog&#34;
  }
}
filter {
  if [program] =~ /trafficserver.+access/ {
    grok {
      patterns_dir =&gt; [ &#34;/etc/logstash/patterns&#34; ]
      match =&gt; [ &#34;message&#34;, &#34;%{TRAFFICSERVER_ACCESS}&#34; ]
      add_tag =&gt; [ &#34;trafficserver&#34; ]
    }
    date {
      locale =&gt; &#34;en&#34;
      timezone =&gt; &#34;+03:00&#34;
      match =&gt; [ &#34;ats_timestamp&#34;, &#34;UNIX&#34; ]
    }
  }
}
output {
  if [type] == &#34;syslog&#34; {
    if [program] =~ /trafficserver.+access/ {
      statsd {
        host =&gt; &#39;graphite.example.com&#39;
        count =&gt; [ &#34;trafficserver.response_%{http_status_code}.%{cache_result}.bytes_read&#34;, &#34;%{bytes_read}&#34; ]
        sender =&gt; &#34;%{logsource}&#34;
      }
      statsd {
        host =&gt; &#39;graphite.example.com&#39;
        count =&gt; [ &#34;trafficserver.response_%{http_status_code}.%{cache_result}.msec&#34;, &#34;%{request_msec}&#34; ]
        sender =&gt; &#34;%{logsource}&#34;
      }
      statsd {
        host =&gt; &#39;graphite.example.com&#39;
        increment =&gt; &#34;trafficserver.response_%{http_status_code}.%{cache_result}&#34;
        sender =&gt; &#34;%{logsource}&#34;
      }
    }
  }
}
</code></pre><p>Теперь я могу оценить, насколько медленнее отдаются те запросы, которые не попали
в кеш ATS, и настроить алерты на повышение доли не-20х кодов ответов.</p>
<h4 id="закономерный-вопрос">Закономерный вопрос</h4>
<p>Если <a href="https://www.elastic.co/products/kibana">Kibana</a> так хороша, и может
строить графики по любым метрикам, зачем же пихать
эти данные в Graphite?</p>
<p>Отвечаю - графики в Kibana это отлично, но очень уж дорого
по ресурсам. Elasticsearch вынужден держать весь индекс в памяти, и в отличие от
Graphite он не может уменьшать разрешение метрик со временем. Так что использование
Graphite позволяет делать алерты по таким метрикам гораздо менее ресурсоемкими,
и хранить метрики несоизмеримо дольше. Ну и весь набор функций Graphite в нашем
распоряжении.</p>

</main>


<p class="terms">
<b>Tags:</b>

  <a href="//bulimov.me/tags/graphite/">Graphite</a>

  <a href="//bulimov.me/tags/monitoring/">Monitoring</a>

  <a href="//bulimov.me/tags/logstash/">Logstash</a>

  <a href="//bulimov.me/tags/statsd/">StatsD</a>

  <a href="//bulimov.me/tags/%D0%BE%D0%BF%D1%8B%D1%82/">Опыт</a>


</p>
<p class="terms">

<b>Categories:</b>

  <a href="//bulimov.me/categories/it/">IT</a>

  <a href="//bulimov.me/categories/russian/">Russian</a>


</p>

  <footer>
  
  
  <hr/>
  <a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" alt="License: CC BY-SA 4.0"></a> © <a href="http://bulimov.me">Alexander Bulimov</a> 2013 &ndash; 2022 | <a href="https://github.com/abulimov">Github</a>
  
  </footer>
  </body>
</html>

