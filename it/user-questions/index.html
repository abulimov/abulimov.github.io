<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Вопросы от Дениса | Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="https://models.bulimov.me">Scale Models</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/reviews/">Reviews</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Вопросы от Дениса</span></h1>

<h2 class="date">2017/05/27</h2>

</div>

<main>
<p>Пришло письмо от читателя по имени Денис по форме обратной связи.
Поскольку никаких данных для связи с ним Денис не оставил, отвечу здесь.</p>
<p>Привожу письмо полностью (надеюсь, автор не против):</p>
<blockquote>
<p>Александр, здравствуйте! Не смог найти вашу электропочту, пишу через форму обратной связи вашего домена на рег.ру :)</p>
</blockquote>
<blockquote>
<p>С огромным удовольствием читаю твой блог, очень жаль, что больше не обновляешь его.</p>
</blockquote>
<blockquote>
<p>Помоги, пожалуйста, советом.
У меня примерно 12 виртуальных серверов с небольшими микросервисами, на каждом из серверов
поставил collectd и statsd, плюс на отдельном сервере развёрнул go-carbon - whisper - graphite-api - Grafana.</p>
</blockquote>
<blockquote>
<p>Сейчас хочу как-то опрашивать эти микросервисы извне (http, https) и мониторить коды их ответов (200 - всё хорошо, иной ответ - всё плохо, нужно алертить по смс). Как это лучше сделать? Первое, что мне пришло в голову - написать свой костыльный bash-скрипт, который будет по очереди все нужные эндпоинты опрашивать и в go-carbon-&gt;whisper пулять&hellip; Второе, что пришло в голову - опять же написать свой костыльный плагин к collectd :)</p>
</blockquote>
<blockquote>
<p>Но очень не хочется переизобретать велосипед, наверняка же есть какие-то удобные готовые инструменты для этого?
Что для данной задачи использовать? Nagios, Icinga2, Zabbix, Sensu, что-то другое?</p>
</blockquote>
<blockquote>
<p>Я правильно понимаю, что для этой задачи time-seried БД подходит плохо, т.к. длительность ответа микросервиса всегда немного разная и очень трудно настроить задержку (sleep) в том же bash-скрипте, чтобы попасть ровно одним реквестом в каждый агрегируемый интервал 10 сек для collectd/whisper. Т.е. лучше опрашивать не строго через каждые 10 сек, а неважно через какие промежутки, можно даже не совсем одинаковые (плюс-минус пара секунд), но для ответов использовать ещё какое-то хранилище аварийных events? Если да, то какое? Elasticsearch ещё прикрутить и из него в графану дашборд для алертинга?</p>
</blockquote>
<blockquote>
<p>P.S.: наверное, лучше всего чтобы сам микросервис коды ответов на реквесты в statsd отсылал? но вопрос именно про готовый внешний &ldquo;проверяльщик&rdquo; здоровья системы, чем бы воспользовался лично ты для решения такой задачи?</p>
</blockquote>
<p>Я бы для решения подобной задачи не стал городить велосипеды, а воспользовался бы Icinga2 с плагином check_http из пакета Nagios-plugins, или каким-то более продвинутым плагином с <a href="https://exchange.icinga.com">Icinga exchange</a>. Можно конечно и обычный Nagios использовать, но Icinga2 умеет из коробки писать результаты проверок в Graphite, который у Дениса уже есть.</p>
<p>Идея с микросервисом, отсылающим данные в statsd, мне не нравится, так как polling на таких масштабах сильно проще, его проще тестировать и проверять из любого места, и микросервису не нужно знать ничего про сервис монторинга - это сильно упрощает конфигурирование. Если хочется собирать данные на уровне микросервиса (инструментировать) - можно посмотреть в сторону <a href="https://prometheus.io/">Prometheus</a>, так как в любом случае нужно что-то, что будет реагировать на отсутствие heartbeat от сервиса.</p>
<p>Time-series DB для такой задачи подходит нормально, а Elasticsearch в любом случае было бы отлично прикрутить для логов. К тому же с ним можно использовать
<a href="https://www.elastic.co/products/beats/packetbeat">Packetbeat</a> для того же мониторинга (если нагрузка небольшая, конечно).</p>
<p>Ну и немного о том, почему я давно ничего тут не пишу. Дело в том, что в любой
крупной IT-компании типа Google/Facebook/Amazon/MailRU/Yandex
бо́льшая часть инфраструктуры своя, а решаемые задачи в силу масштабов не сильно
интересны нормальным компаниям и стартапам.
Кроме того, трудовой договор подразумевает согласование любых открытий кода с юристами (что совершенно логично). Так что этот блог я пытаюсь преобразовать
в более персональный - пока без особого успеха, как можно заметить.</p>

</main>


<p class="terms">
<b>Tags:</b>

  <a href="//bulimov.me/tags/monitoring/">Monitoring</a>

  <a href="//bulimov.me/tags/icinga2/">Icinga2</a>

  <a href="//bulimov.me/tags/graphite/">Graphite</a>

  <a href="//bulimov.me/tags/elasticsearch/">Elasticsearch</a>

  <a href="//bulimov.me/tags/packetbeat/">Packetbeat</a>


</p>
<p class="terms">

<b>Categories:</b>

  <a href="//bulimov.me/categories/it/">IT</a>

  <a href="//bulimov.me/categories/russian/">Russian</a>


</p>

  <footer>
  
  
  <hr/>
  <a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" alt="License: CC BY-SA 4.0"></a> © <a href="http://bulimov.me">Alexander Bulimov</a> 2013 &ndash; 2023 | <a href="https://github.com/abulimov">Github</a>
  
  </footer>
  </body>
</html>

