<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Разбирался с page-cache в Linux | Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="https://models.bulimov.ru">Scale Models</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/reviews/">Reviews</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Разбирался с page-cache в Linux</span></h1>

<h2 class="date">2014/10/09</h2>

</div>

<main>
<p>Читая книгу <a href="http://www.williamspublishing.com/Books/5-8459-1085-4.html">&ldquo;Разработка ядра Linux&rdquo;</a> за авторством Роберта Лава,
я решил поглубже разобраться в том, как работает кэш в Linux,
и набрел на вот <a href="http://habrahabr.ru/company/yandex/blog/231957/">эту</a>
статью на Хабре от Яндекса.</p>
<p>Сама статья весьма познавательна, особенно видео - рекомендую.
Так вот, в этом видео <em>Роман Гущин</em>, с помощью простой утилиты, наглядно показывающей
размер кэша, показывал как работает файловый кэш.</p>
<p>Конечно, мне захотелось в образовательных целях написать такую утилиту для себя,
чтобы можно было поиграться с кэшем и видеть изменения.</p>
<p>Выбрал я для реализации свой любимый Python в связке с Qt(PySide).</p>
<p>Вот весь код:</p>
<pre><code>:::python

import sys
from PySide import QtGui, QtCore


class MemoryDrawer(QtGui.QWidget):

    def __init__(self):
        super(MemoryDrawer, self).__init__()

        self.initUI()
        self.data = dict()
        self.getData()

    def initUI(self):

        self.setWindowTitle('/proc/meminfo visualizer')
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.onTimer)
        self.timer.start(100)
        self.show()

    def paintEvent(self, e):

        qp = QtGui.QPainter()
        qp.begin(self)
        self.drawRectangles(qp)
        qp.end()

    def drawRectangles(self, qp):

        height = self.geometry().height()
        width = self.geometry().width()
        dataSet = [('MemFree:', 'darkGreen'),
                ('Active(file):', 'darkMagenta'),
                ('Inactive(file):', 'darkRed'),
                ('Cached:', 'darkCyan')]
        offset = 20
        count = len(dataSet)
        sizeX = (width - (count + 1) * offset) // count

        sizeY = height - 2 * offset

        x = offset
        y = offset

        for pos, (data, colorName) in enumerate(dataSet):
            x = (pos + 1) * offset + pos * sizeX
            color = QtGui.QColor(colorName)
            pixmap = self.drawGraph(sizeX, sizeY, data, color)
            qp.drawPixmap(x, y, pixmap)

    def drawGraph(self, width, height, dataKey, color):
        memTotal = self.data['MemTotal:']
        kbPerPixel = height / memTotal

        dataValue = self.data[dataKey]
        drawData = dataValue * kbPerPixel

        pixmap = QtGui.QPixmap(width, height)
        qp = QtGui.QPainter()
        qp.begin(pixmap)
        qp.setBrush(QtGui.QColor(255, 255, 255))
        qp.drawRect(0, 0, width, height)
        qp.setBrush(color)
        qp.drawRect(0, height - drawData, width, height)
        qp.drawText(QtCore.QPoint(5, 20), dataKey)
        qp.drawText(QtCore.QPoint(5, 40), &quot;%s kb&quot; % dataValue)
        qp.end()
        return pixmap

    def getData(self):
        with open('/proc/meminfo') as f:
            for line in f.readlines():
                if line:
                    splitted = line.split()
                    self.data[splitted[0]] = int(splitted[1])

    def onTimer(self):
        self.getData()
        self.update()


def main():
    app = QtGui.QApplication(sys.argv)
    drawer = MemoryDrawer()
    drawer.show()
    sys.exit(app.exec_())


if __name__ == '__main__':
    main()
</code></pre>
<p>Актуальная версия визуализатора <a href="https://github.com/abulimov/utils/blob/master/scripts/meminfo.py">лежит</a> в моем репозитории.</p>
<p>Теперь можно самому повторить эксперимент из видео на новых ядрах,
и посмотреть, что же изменилось.</p>
<p>Предварительно надо создать пару больших файлов, для 8Gb оперативки
нам нужны 1Gb и 8Gb файлы. Создать их можно из /dev/urandom примерно так:</p>
<pre><code>dd if=/dev/urandom bs=1k count=1048576 of=/path/to/large
dd if=/dev/urandom bs=1k count=8388608 of=/path/to/large2
</code></pre>
<p>А еще надо собрать <a href="https://github.com/hoytech/vmtouch">vmtouch</a>:</p>
<pre><code>wget https://raw.github.com/hoytech/vmtouch/master/vmtouch.c
gcc -Wall -O3 -o vmtouch vmtouch.c
chmod +x ./vmtouch
</code></pre>
<p>Ну а теперь повторяем эксперимент из видео. Я использовал ядро Linux 3.13.</p>
<p>Для начала, сбросим кэши:</p>
<pre><code>echo 3 | sudo tee /proc/sys/vm/drop_caches
</code></pre>
<p>Запустим визуализатор:</p>
<pre><code>python3 meminfo.py
</code></pre>
<p>У нас есть два больших файлика - large и large2:</p>
<p>Прочитаем large, чтобы он попал в inactive cache:</p>
<pre><code>cat large &gt; /dev/null
</code></pre>
<p>Прочитаем его еще раз, чтобы он попал в active cache:</p>
<pre><code>cat large &gt; /dev/null
</code></pre>
<p>Теперь можно натравить на него vmtouch:</p>
<pre><code>vmtouch -m 1g -v large
</code></pre>
<p>Выдавим его из кэша:</p>
<pre><code>vmtouch -m 1g -e large
</code></pre>
<p>Снова прочитаем large, чтобы он попал в inactive cache:</p>
<pre><code>cat large &gt; /dev/null
</code></pre>
<p>Теперь прочитаем large2</p>
<pre><code>cat large2 &gt; /dev/null
</code></pre>
<p>и видим, что он вытесняет large из inactive cache.</p>
<p>А теперь сбросим снова кэши, и запихнем large в active cache:</p>
<pre><code>echo 3 | sudo tee /proc/sys/vm/drop_caches
cat large &gt; /dev/null
cat large &gt; /dev/null
</code></pre>
<p>И попробуем прочитать large2:</p>
<pre><code>cat large2 &gt; /dev/null
</code></pre>
<p>Теперь мы можем видеть, что large2 не может вытеснить large из active cache,
о чем и говорилось в видео.</p>
<p>А еще видно, как колеблется количество свободной памяти, из-за периодического
характера работы kswapd.</p>
<p>Если посмотреть с помощью vmtouch, какая часть large2 попала в inactive cache,
то мы увидим, что он при чтении вытеснял сам себя.</p>
<pre><code>vmtouch -m 8g -v large2
</code></pre>
<p>Теперь можно удалить large, и увидеть, как освободился active cache, а потом
удалить large2 и увидеть, как освободился inactive cache.</p>
<p>Вот такой вот опыт позволяет увидеть некоторые проблемы в работе с кэшами в актуальных
ядрах Linux. Будет интересно повторить эксперимент на свежих ядрах после улучшений
в области Memory Management.</p>

</main>


<p class="terms">
<b>Tags:</b>

  <a href="//bulimov.me/tags/kernel/">Kernel</a>

  <a href="//bulimov.me/tags/python/">Python</a>

  <a href="//bulimov.me/tags/%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">Программирование</a>

  <a href="//bulimov.me/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/">Книги</a>


</p>
<p class="terms">

<b>Categories:</b>

  <a href="//bulimov.me/categories/it/">IT</a>

  <a href="//bulimov.me/categories/russian/">Russian</a>


</p>

  <footer>
  
  
  <hr/>
  <a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" alt="License: CC BY-SA 4.0"></a> © <a href="http://bulimov.me">Alexander Bulimov</a> 2013 &ndash; 2021 | <a href="https://github.com/abulimov">Github</a>
  
  </footer>
  </body>
</html>

