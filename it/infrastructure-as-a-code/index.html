<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Инфраструктура как код | Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="https://models.bulimov.ru">Scale Models</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/reviews/">Reviews</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Инфраструктура как код</span></h1>

<h2 class="date">2014/09/29</h2>

</div>

<main>
<p>Есть такой тренд сейчас - работать с IT-инфраструктурой как с кодом.
Хорошо цель этого метода описывается этой цитатой:</p>
<blockquote>
<p>“Enable the reconstruction of the business from nothing but a source code repository, an application data backup, and bare metal resources”</p>
<p>&ndash; Jesse Robins</p>
</blockquote>
<p>Я полностью поддерживаю эту идею, причем именно в этой трактовке.</p>
<p>Если говорить про парадигму, которую нам предлагает этот метод, то вот она:</p>
<blockquote>
<p>Поддерживать модульную, легко поддающуюся автоматизации инфраструктуру,
и <em>описывать</em> эту инфраструктуру с помощью языка высокого уровня.</p>
</blockquote>
<p>Это означает для нас, как сисадминов, что мы должны пользоваться всеми
наработками разработчиков ПО, такими как:</p>
<ul>
<li>версионирование описания инфраструктуры;</li>
<li>полноценное тестирование описания с использованием нескольких стадий (dev, QA, staging, prod);</li>
<li>внутренние стандарты &ldquo;кодинга&rdquo;;</li>
<li>непрерывная интеграция (continuous integration).</li>
</ul>
<p>Проблема же, на мой взгляд, заключается в том, что многие понимают
&ldquo;Инфраструктуру как код&rdquo; в другом смысле - &ldquo;Давайте писать описание нашей
инфраструктуры с помощью Chef/Puppet, словно это обычный код&rdquo;.
Причем у Chef это выражено заметно сильнее, поскольку в качестве DSL используется
чистый Ruby.</p>
<p>Конечно, программисты, каким-либо образом ставшие ответственными за
администрирование серверов с помощью Chef, с радостью начинают использовать
привычный инструмент (Ruby) привычным же образом, и получается ровно то,
что они привыкли делать.
Вместо декларативного описания инфраструктуры, на которое можно натравить какой-нибудь
инструмент для управления конфигурациями и получить настроенную инфраструктуру,
на выходе получаем программу с кучей хаков, с множественным ветвлением,
с выполнением кода на Shell, которая может императивно привести
систему к нужному состоянию.</p>
<p>Примером может являться практически любой стандартный кукбук Chef.
Взять хотя-бы <a href="https://github.com/miketheman/nginx">Nginx cookbook</a>.
Он умеет ставить Nginx несколькими способами, включая сборку из исходников,
и содержит в себе тонну переменных, призванных заменить написание вменяемого
шаблона конфига Nginx заданием значений этой кучи переменных.</p>
<p>Это уже сам по себе плохой подход - пытаться впихнуть все возможности
Nginx (да еще и со сторонними модулями) в один мега-шаблон, и править только
переменные.</p>
<p>Сборка из исходников в кукбуке тоже вызывает массу вопросов. Зачем это делать на
боевом сервере? Собрать пакет на build-сервере, протестировать его, и
распространить из своего репозитория по всем серверам - вот это нормальный подход.</p>
<p>И все это порождает столько сложностей, столько труда нужно для написания,
тестирования и поддержания в актуальном состоянии этого кукбука,
вместо того, чтоб разделить весь процесс на несколько простых шагов:</p>
<ul>
<li>Собрать пакет Nginx с нужными модулями на build-сервере, протестировать и поместить в репозиторий;</li>
<li>Написать шаблон конфига Nginx под ваши задачи, учитывающий различия между
имеющимися средами (staging/prod);</li>
<li>Написать кукбук/манифест/роль, который будет ставить пакет из вашего
репозитория, заполнять шаблон переменными, которые отличаются в ваших окружениях,
и класть этот шаблон на сервер.</li>
</ul>
<p>Вот и все, не нужны тонны кода на Ruby со вставками на Shell, не нужны сотни
переменных. У нас есть описание процесса сборки пакета (spec-файл или
Makefile), и декларативное описание требуемого состояния системы.</p>
<p>И это прекрасно подходит под один из принципов <a href="https://ru.wikipedia.org/wiki/%D0%AD%D0%BA%D1%81%D1%82%D1%80%D0%B5%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Экстремального Программирования</a>, который звучит так:</p>
<blockquote>
<p>Do The Simplest Thing That Could Possibly Work</p>
</blockquote>
<p>То есть, надо сделать так, чтобы наш кукбук/манифест/роль был достаточно простым
для того, чтобы удовлетворять нашим <em>сегодняшним</em> требованиям.
Конечно, увлекаться и делать что-то &ldquo;в лоб&rdquo;, не думая, будет неверно, но и
создавать псевдо-универсальных монстров точно не стоит. Во всем нужна мера.</p>
<p>Что самое плохое - люди, которые пишут сам Chef, и написали этот кукбук для Nginx.
Написали хорошо, но написали как программисты, а не как системные администраторы.
А когда сисадмины пишут кукбуки в таком стиле, на их творения вообще без
слез не взглянешь.</p>
<p>Именно поэтому я выбрал для
управления серверами Ansible, созданный Michael DeHaan, человеком, который
работал в Puppet Labs, создал Func и Cobbler, а затем, имея большой опыт и видя
ошибки предшественников, написал Ansible. Ansible заметно проще Chef или Puppet,
и декларативный yaml-файл с описанием требуемого состояния системы ограничивает
возможность выстрелить себе в ногу и наворотить лапшеобразного императивного кода.</p>
<p>Если эту заметку прочтут программисты, администрирующие сервера - перестаньте
толковать &ldquo;Инфраструктуру как код&rdquo; неверно! Мы берем лучшие наработки из
мира программирования, но это не традиционное программирование. Не надо
переизобретать Bash-скрипты на Ruby.</p>

</main>


<p class="terms">
<b>Tags:</b>

  <a href="//bulimov.ru/tags/chef/">Chef</a>

  <a href="//bulimov.ru/tags/ansible/">Ansible</a>

  <a href="//bulimov.ru/tags/%D0%BC%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5/">Мнение</a>


</p>
<p class="terms">

<b>Categories:</b>

  <a href="//bulimov.ru/categories/it/">IT</a>

  <a href="//bulimov.ru/categories/russian/">Russian</a>


</p>

  <footer>
  
  
  <hr/>
  <a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" alt="License: CC BY-SA 4.0"></a> © <a href="http://bulimov.ru">Alexander Bulimov</a> 2013 &ndash; 2021 | <a href="https://github.com/abulimov">Github</a>
  
  </footer>
  </body>
</html>

