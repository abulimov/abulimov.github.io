<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Открыл код db-checker | Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="https://models.bulimov.ru">Scale Models</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/reviews/">Reviews</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Открыл код db-checker</span></h1>

<h2 class="date">2016/03/18</h2>

</div>

<main>
<p>Недавно я открыл код еще одного инструмента, который уже около года использую на работе -
<a href="https://github.com/abulimov/db-checker">db-checker</a>.</p>
<p>Началось все с необходимости проводить регулярные проверки логической
целостности данных в БД. Проще говоря - гонять мониторингом запросы к базе.</p>
<p>Сначала это была часть проекта, который проверял данные на нашем CDN.
Проект этот сразу планировался многопоточным, поэтому написан на <a href="http://golang.org">Go</a>.
Затем мухи были отделены от котлет, и проверка базы выделилась в отдельную
сущность, но несколько legacy-моментов осталось.</p>
<p>Главной проблемой было то, что проверки определялись в коде, поэтому
добавление новой проверки было относительно нетривиальной задачей,
а код проекта невозможно было сделать открытым. Долгое время у меня не было
времени на устранение этого недостатка, но недавно я взялся за эту задачу.</p>
<h3 id="db-checker">db-checker</h3>
<p>Результатом стал проект <a href="https://github.com/abulimov/db-checker">db-checker</a>,
который работает как Nagios-совместимый плагин, и позволяет:</p>
<ul>
<li><strong>читать описание проверок из простых <a href="http://yaml.org">YAML</a>-файлов</strong></li>
<li><strong>делать запросы к PostgreSQL/MySQL и проверять наличие/отсутствие результата</strong></li>
<li><strong>выводить полученные данные в удобной табличной форме</strong></li>
<li><strong>сохранять состояние прошлой проверки и выводить алерты только для новых проблем</strong></li>
</ul>
<p>Пройдемся по каждому пункту отдельно.</p>
<h4 id="читать-описание-проверок-из-простых-yamlhttpyamlorg-файлов">Читать описание проверок из простых <a href="http://yaml.org">YAML</a>-файлов</h4>
<p>Я очень люблю <a href="http://yaml.org">YAML</a> как формат для конфигов, и описание
проверок в нем выглядят крайне лаконично и просто (примеры в следующем пункте).
При этом хранение проверок отдельно от инструмента очень удобно и дает возможность
очень легко добавлять новые проверки любому человеку.</p>
<p>Все описание проверки состоит всего из 3х обязательных полей:</p>
<ul>
<li>query: любой SQL-запрос</li>
<li>description: Описание проверки</li>
<li>assert: что мы ожидаем от результата выполнения запроса, <em>present</em> или <em>absent</em></li>
</ul>
<h4 id="делать-запросы-к-postgresqlmysql-и-проверять-наличиеотсутствие-результата">Делать запросы к PostgreSQL/MySQL и проверять наличие/отсутствие результата</h4>
<p>Все проверки целостности данных в базе можно выразить
в форме SQL-запроса, который либо возвращает ОК в случае пройденной проверки,
и тогда мы проверяем <em>наличие</em> данных в ответе на запрос, либо мы запрашиваем
список того, чего быть не должно, и тогда мы проверяем <em>отсутствие</em> данных
в ответе на запрос, а при наличии - выводим их в отчете.</p>
<p>Например, наличие блокировок в PostgreSQL можно проверять так:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">query</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    SELECT
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      COALESCE(blockingl.relation::regclass::text,blockingl.locktype) as locked_item,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      (now() - blockeda.query_start)::time AS waiting_duration,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      blockeda.pid AS blocked_pid,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      blockeda.query as blocked_query, blockedl.mode as blocked_mode,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      blockinga.pid AS blocking_pid, blockinga.query as blocking_query,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      blockingl.mode as blocking_mode
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    FROM pg_catalog.pg_locks blockedl
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    JOIN pg_stat_activity blockeda ON blockedl.pid = blockeda.pid
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    JOIN pg_catalog.pg_locks blockingl ON(
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      ( (blockingl.transactionid=blockedl.transactionid) OR
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      (blockingl.relation=blockedl.relation AND blockingl.locktype=blockedl.locktype)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      ) AND blockedl.pid != blockingl.pid)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    JOIN pg_stat_activity blockinga ON blockingl.pid = blockinga.pid
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      AND blockinga.datid = blockeda.datid
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    WHERE NOT blockedl.granted;</span>    
</span></span><span style="display:flex;"><span><span style="color:#f92672">description</span>: <span style="color:#ae81ff">Locks in database</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">assert</span>: <span style="color:#ae81ff">absent</span>
</span></span></code></pre></div><p>Таким образом, если блокировок нет - все отлично, а если есть - выводим их список.</p>
<p>Другой пример - проверка успешных задач <code>job_name</code> PGAgent за 4 часа:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">query</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    SELECT jlgstatus
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    FROM pgagent.pga_joblog
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    WHERE jlgstart &gt; (now() - interval &#39;4 hours&#39;) AND jlgstatus = &#39;s&#39; AND
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    jlgjobid=(
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    SELECT jobid FROM pgagent.pga_job WHERE jobname = &#39;job_name&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    )
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ORDER BY jlgstart DESC LIMIT 1;</span>    
</span></span><span style="display:flex;"><span><span style="color:#f92672">description</span>: <span style="color:#ae81ff">Не было успешных запусков job_name за прошедший час</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">assert</span>: <span style="color:#ae81ff">present</span>
</span></span></code></pre></div><p>В этом случае мы ждем, что Query вернет нам список задач, а если нет - алерт.</p>
<h4 id="выводить-полученные-данные-в-удобной-табличной-форме">Выводить полученные данные в удобной табличной форме</h4>
<p>Поскольку сообщения из алертов читают люди, надо показывать проблему так, чтобы
сразу было все понятно, поэтому ASCII-таблица с проблемными значениями подходит
как нельзя лучше.</p>
<p>Пример:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>nagios@example.com:~$ ./db-checker --dbname movies --dbuser=checker --dbhost=localhost --dbpassword=SomePassword --checks /opt/checks/movies --critical
</span></span><span style="display:flex;"><span>CRITICAL:
</span></span><span style="display:flex;"><span>* Found movies with zero duration
</span></span><span style="display:flex;"><span>N. ¦ column1 ¦ orig_title                ¦ rus_title
</span></span><span style="display:flex;"><span>1. ¦ 1346    ¦ Midnight Express          ¦ Полуночный экспресс
</span></span><span style="display:flex;"><span>2. ¦ 2165    ¦ In the Loop               ¦ В петле
</span></span><span style="display:flex;"><span>3. ¦ 2254    ¦ Sex &amp; Drugs &amp; Rock &amp; Roll ¦ Секс, наркотики и рок-н-ролл
</span></span><span style="display:flex;"><span>4. ¦ 2534    ¦ Resident Evil: Damnation  ¦ Обитель Зла: Проклятие
</span></span></code></pre></div><h4 id="сохранять-состояние-прошлой-проверки-и-выводить-алерты-только-для-новых-проблем">Сохранять состояние прошлой проверки и выводить алерты только для новых проблем</h4>
<p>Предположим, у нас есть некая таблица биллинга, в которой содержатся записи
о транзакциях пользователей. Иногда случаются подозрительные повторные платежи,
о каждом из которых стоит слать уведомление, но лишь единожды. При этом
транзакции из таблицы никуда не пропадают. Вот как раз для такого случая
есть <code>--diff</code> режим, который позволяет уведомлять только о новых проблемах.</p>
<h4 id="прочие-особенности">Прочие особенности</h4>
<p>Поскольку проект написан на Go, грех было не реализовать параллельное выполнение
проверок (настраивается с помощью флага <code>--concurrent-checks</code>).</p>
<p>И конечно я постарался весь важный код покрыть тестами.</p>
<h3 id="альтернативы">Альтернативы</h3>
<p>До принятия решения о написании своего велосипеда я изучал уже готовые утилиты.
Самое близкое по функционалу, что я нашел - <a href="https://bucardo.org/check_postgres/check_postgres.pl.html">check_postgres.pl</a>,
монструозный скрипт на Perl с более чем 8k строк кода, зато с возможностью запускать
ограниченное подмножество запросов через <code>custom_query</code>. Под мои задачи он не подошел,
но штука впечатляющая.</p>
<h3 id="заключение">Заключение</h3>
<p>Больше информации и примеры проверок можно найти в <a href="https://github.com/abulimov/db-checker">репозитории проекта</a>,
код опубликован под лицензией <a href="http://opensource.org/licenses/MIT">MIT</a>.</p>

</main>


<p class="terms">
<b>Tags:</b>

  <a href="//bulimov.me/tags/%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">Программирование</a>

  <a href="//bulimov.me/tags/golang/">Golang</a>

  <a href="//bulimov.me/tags/nagios/">Nagios</a>

  <a href="//bulimov.me/tags/monitoring/">Monitoring</a>


</p>
<p class="terms">

<b>Categories:</b>

  <a href="//bulimov.me/categories/it/">IT</a>

  <a href="//bulimov.me/categories/russian/">Russian</a>


</p>

  <footer>
  
  
  <hr/>
  <a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" alt="License: CC BY-SA 4.0"></a> © <a href="http://bulimov.me">Alexander Bulimov</a> 2013 &ndash; 2022 | <a href="https://github.com/abulimov">Github</a>
  
  </footer>
  </body>
</html>

