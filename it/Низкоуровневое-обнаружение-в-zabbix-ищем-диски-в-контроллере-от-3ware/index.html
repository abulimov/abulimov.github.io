<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Низкоуровневое обнаружение в Zabbix, ищем диски в контроллере от 3ware | Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <style>
@media (prefers-color-scheme: dark) {
  body {
    background-color: white;
  }
  html, img, video, iframe {
    filter: invert(1);
  }
}
</style>

  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Blog</a></li>
      
      <li><a href="https://models.bulimov.me">Scale Models</a></li>
      
      <li><a href="/etc/">Etc</a></li>
      
      <li><a href="/about/">About Me</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Низкоуровневое обнаружение в Zabbix, ищем диски в контроллере от 3ware</span></h1>

<h2 class="date">2013/08/14</h2>

</div>

<main>
<p>Я уже <a href="/it/%D0%9D%D0%B8%D0%B7%D0%BA%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%BE%D0%B5-%D0%BE%D0%B1%D0%BD%D0%B0%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-zabbix"> писал </a> про <a href="https://www.zabbix.com/documentation/ru/2.0/manual/discovery/low_level_discovery">низкоуровневое обнаружение</a>
в Zabbix, так что повторять теорию не буду.</p>
<p>Теперь мне понадобилось автоматом получать список хардов в массивах
на контроллерах 3ware, которыми оборудованы у нас многие сервера.</p>
<p>Вести руками шаблоны для каждого сервера с иным порядком или количеством дисков
показалось мне плохой идеей, да и авто-обнаружение само напрашивалось.</p>
<p>Вдохновлялся я утилитой 3ware-status, для работы авто-обнаружения нам потребуется
установленная утилита tw-cli, взять ее для Debian/Ubuntu проще всего <a href="http://hwraid.le-vert.net/"> здесь </a>.</p>
<p>Работает скрипт примерно так:</p>
<ol>
<li>Получаем общую информацию командой <code>tw-cli info</code>, вычленяем оттуда список
контроллеров простенькой регуляркой <code>^c[0-9]+$</code></li>
<li>Получаем информацию для каждого контроллера <code>tw-cli %controller info</code>, опять-таки
регуляркой <code>^[p][0-9]+$</code> вытаскиваем оттуда список хардов</li>
<li>Отдаем полученный список в формате JSON</li>
<li>Используем полученные данные в шаблонах заббикса, в разделе <em>обнаружение</em>,
чтобы вытащить статусы каждого диска в массиве с помощью 3ware-status или tw-cli</li>
</ol>
<p>На выходе должны получить что-то вроде этого:</p>
<pre><code>:::json
{
  &quot;data&quot;: [
    {&quot;{#3WARE_DISK}&quot;: &quot;c0u0p0&quot;},
    {&quot;{#3WARE_DISK}&quot;: &quot;c0p0u1&quot;},
    {&quot;{#3WARE_DISK}&quot;: &quot;c0p1u2&quot;},
    {&quot;{#3WARE_DISK}&quot;: &quot;c0p1u3&quot;}
  ]
}
</code></pre>
<p>Реализовано все на Python, благо он есть по-умолчанию практически в любом дистрибутиве.</p>
<p><strong>3ware_discovery.py</strong></p>
<pre><code>:::python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
import subprocess
import sys
import json
import re

binary_path = &quot;/usr/sbin/tw-cli&quot;

def _run(cmd):
    # returns (rc, stdout, stderr) from shell command
    process = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE, shell=True)
    stdout, stderr = process.communicate()
    return (process.returncode, stdout, stderr)

def _fail(msg):
    print(msg)
    sys.exit(1)

def parse_controllers(data):
    controllers = []
    for line in data.splitlines():
        if line:
            splitted = line.split()
            if re.match(r'^c[0-9]+$', splitted[0]):
                controllers.append(splitted[0])
    return controllers

def parse_disks(data, controller):
    disks = []
    for line in data.splitlines():
        if line:
            splitted = line.split()
            if re.match(r'^[p][0-9]+$', splitted[0]):
                # '-' means the drive doesn't belong to any array
                # If is NOT PRESENT too, it just means this is an empty port
                if not splitted[2] == '-' and not splitted[1] == 'NOT-PRESENT':
                    disks.append({
                        '{#3WARE_DISK}': controller + splitted[2] + splitted[0]
                    })
    return disks

def main():
    disks_list = []

    rc, raw_data, err = _run(&quot;%s info&quot;%binary_path)
    if rc != 0:
        _fail(&quot;tw-cli command failed with %s &quot;%err)
    controllers_list = parse_controllers(raw_data)

    for controller in controllers_list:
        rc, raw_data, err = _run(&quot;%s info %s&quot;%(binary_path, controller))
        if rc != 0:
            _fail(&quot;tw-cli command failed with %s &quot;%err)
        disks_list.extend(parse_disks(raw_data, controller))

    data = {
        'data': disks_list
    }
    print json.dumps(data)

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<p>Ну и конечно нужно создать ключ, по которому заббикс будет список дисков получать.</p>
<p>В конфиге заббикса добавляем строку вида</p>
<pre><code>UserParameter=3ware.discovery,sudo /opt/3ware_discovery.py
</code></pre>
<p>В этом случае, нужно беспарольное sudo на эту команду для пользователя Zabbix.</p>
<p>Ну а в самом заббиксе уже создаем в шаблоне обнаружение, в котором используем ключ
3ware.discovery и макрос {#3WARE_DISK}, например 3ware.disk_status[{#3WARE_DISK}].
Подробности - в документации.</p>
<p>Исходники доступны в моем <a href="https://github.com/abulimov/utils">репозитории</a>, в папке <em><code>zabbix/data_collectors</code></em>.</p>

</main>


<p class="terms">
<b>Tags:</b>

  <a href="//bulimov.me/tags/zabbix/">Zabbix</a>

  <a href="//bulimov.me/tags/python/">Python</a>

  <a href="//bulimov.me/tags/monitoring/">Monitoring</a>


</p>
<p class="terms">

<b>Categories:</b>

  <a href="//bulimov.me/categories/it/">IT</a>

  <a href="//bulimov.me/categories/russian/">Russian</a>


</p>




  <footer>
  
  
  <hr/>
  <a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" alt="License: CC BY-SA 4.0"></a> © <a href="http://bulimov.me">Alexander Bulimov</a> 2013 &ndash; 2025 | <a href="https://github.com/abulimov">Github</a>
  
  </footer>
  </body>
</html>

