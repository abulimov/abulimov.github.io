<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Улучшаем сообщения от мониторинга с помощью cAdvisor-companion | Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="https://models.bulimov.ru">Scale Models</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/reviews/">Reviews</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Улучшаем сообщения от мониторинга с помощью cAdvisor-companion</span></h1>

<h2 class="date">2015/04/21</h2>

</div>

<main>
<p>Слышали ли вы когда-нибудь о такой практике, как &ldquo;Monitoring Events Enrichment&rdquo;?
Если вкратце, то это практика наполнения дополнительной информацией сообщений
от мониторинга, так что на выяснение причины проблемы уходит меньше времени
и телодвижений.</p>
<p>Есть даже контора, которая помогает внедрять эту практику на коммерческой основе,
у них на <a href="http://www.eventenrichment.com/">сайте</a> есть неплохие примеры того,
что и зачем можно добавить к обычному сообщению от Nagios.</p>
<p>Сама эта идея мне очень нравится, и вот после очередного неинформативного
сообщения от <a href="http://bulimov.ru/it/check-cadvisor/">мониторинга</a>,
которое пришло тогда, когда я был далеко от компьютера, и гласило
<code>CheckDockerStats CRITICAL: 91% CPU Used!</code>, я решил добавить
таким сообщениям полезного контекста.</p>
<p>Конечно, очевидным кандидатом на добавление к сообщению от мониторинга
в данном случае является список процессов в контейнере, отсортированных
по использованию CPU. Если это не кажется очевидным, то представьте, что
вам приходит сообщение от мониторинга, что в каком-то контейнере превышен
порог использования CPU/памяти, а вы не у компьютера, и к тому моменту, как
вы можете проверить, что же там случилось, контейнер уже вернулся к своему
нормальному потреблению ресурсов.</p>
<p>Для обычных проверок <code>check_load</code> и <code>check_memory</code> из пакета Nagios-plugins
я добавил топ-5 потребителей ресурсов достаточно легко - обернул стандратные
плагины в простенький wrapper на bash, получилось примерно так:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span><span style="color:#75715e"># check_memory wrapper</span>
output<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>/usr/lib/nagios/plugins/check_memory <span style="color:#e6db74">&#34;</span>$@<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span>
status<span style="color:#f92672">=</span>$?
message<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$output<span style="color:#e6db74">&#34;</span> | cut -d<span style="color:#ae81ff">\|</span> -f 1<span style="color:#66d9ef">)</span>
perfdata<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$output<span style="color:#e6db74">&#34;</span> | cut -d<span style="color:#ae81ff">\|</span> -f 2<span style="color:#66d9ef">)</span>
echo -n <span style="color:#e6db74">&#34;</span>$message<span style="color:#e6db74">&#34;</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#ae81ff">0</span> -ne <span style="color:#e6db74">&#34;</span>$status<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
  echo
  ps aux --sort -pmem | head -n <span style="color:#ae81ff">5</span>
<span style="color:#66d9ef">fi</span>
echo <span style="color:#e6db74">&#34; | </span>$perfdata<span style="color:#e6db74">&#34;</span>
exit $status
</code></pre></div><p>При превышении заданных лимитов вывод этого wrapperа получается такой:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@host:~# /usr/lib/nagios/plugins/check_memory_wrapper.sh -f -C -w <span style="color:#ae81ff">15</span> -c <span style="color:#ae81ff">10</span>
CRITICAL - 4.9% <span style="color:#f92672">(</span><span style="color:#ae81ff">1198364</span> kB<span style="color:#f92672">)</span> free!
USER       PID %CPU %MEM    VSZ   RSS      TTY  STAT START   TIME COMMAND
traffic+ <span style="color:#ae81ff">28086</span> 11.3 91.7 <span style="color:#ae81ff">25970900</span> <span style="color:#ae81ff">22651436</span> ?    Sl   Mar18 5553:57 /usr/bin/traffic_server -M --httpport 8080:fd<span style="color:#f92672">=</span><span style="color:#ae81ff">9</span>
haproxy  <span style="color:#ae81ff">26404</span>  7.0  0.2 <span style="color:#ae81ff">85832</span>    <span style="color:#ae81ff">59364</span>    ?    Ss   Mar19 3332:04 /usr/sbin/haproxy -f /etc/haproxy/haproxy.cfg -p /var/run/haproxy.pid -D -sf <span style="color:#ae81ff">25137</span>
syslog   <span style="color:#ae81ff">25077</span>  0.5  0.1 <span style="color:#ae81ff">332568</span>   <span style="color:#ae81ff">29764</span>    ?    Ssl  Apr06  109:24 rsyslogd
root     <span style="color:#ae81ff">15342</span>  0.1  0.0 <span style="color:#ae81ff">84124</span>    <span style="color:#ae81ff">15212</span>    ?    S    Mar08   95:21 /usr/bin/perl -w /usr/sbin/ldirectord /etc/ldirectord.cf start
 | TOTAL<span style="color:#f92672">=</span>24678520KB;;;; USED<span style="color:#f92672">=</span>23480156KB;20976742;22210668;; FREE<span style="color:#f92672">=</span>1198364KB;;;; CACHES<span style="color:#f92672">=</span>980600KB;;;;
</code></pre></div><p>и сразу из сообщения о проблеме видно, кто сожрал всю память на сервере.</p>
<p>Для контейнера получить такую информацию сложнее, поскольку:</p>
<ul>
<li>в контейнере может не быть ни NRPE-сервера, ни sshd;</li>
<li>утилиты top, ps и прочие, получающие данные из общесистемных счетчиков
в <code>/proc</code>, показывают в контейнерах <a href="http://fabiokung.com/2014/03/13/memory-inside-linux-containers/">неверные данные</a>;</li>
<li>cAdvisor не предоставляет информации о процессах внутри контейнера.</li>
</ul>
<p>Поскольку информацию об использовании памяти/CPU я беру по HTTP из
<a href="https://github.com/google/cadvisor">cAdvisor</a>,
я решил следовать этому же сценарию и для обогащения сообщений о проблемах,
и написать свой мини-сервис для получения информации о том, какие процессы
запущены в контейнере.</p>
<p>Поскольку сервис получался комплиментарным к cAdvisor, я назвал его
<a href="https://github.com/abulimov/cadvisor-companion">cAdvisor-companion</a>.</p>
<p>В общем, алгоритм решения задачи оказался не сложным - достаточно всего лишь
пройтись по файловой системе <code>/proc</code> на родительском хосте, собрать данные
по всем процессам, и фильтровать их по cgroup.</p>
<p>Поскольку мой сервис должен был собирать в отдельном потоке данные,
и при этом отвечать на HTTP-запросы к API, да еще делать все это быстро, я выбрал
для реализации не привычный Python, а &ldquo;стильный, модный, молодежный&rdquo;
<a href="http://golang.org/">Golang</a>.</p>
<p>Сразу скажу, что это решение оказалось удачным, и позволило мне достаточно
быстро и просто написать этот небольшой сервис, уложившись меньше чем в 500
строк кода вместе с тестами.</p>
<p>Итогом нескольких дней разработки в свободное от работы время стал сервис,
пригодный к разворачиванию в контейнере, которому для работы требуется только
read-only доступ к <code>/proc</code>, и который по HTTP API отдает в виде JSON историю
запущенных процессов для указанного контейнера.</p>
<p>Подробнее о том, как этот сервис запускать, что из себя представляет API, почему
я не стал использовать Docker API, и прочие полезные вещи можно почитать на
<a href="https://github.com/abulimov/cadvisor-companion">github-страничке cAdvisor-companion</a>,
ну а я хочу рассказать как я использую этот самописный сервис, и какие у него
есть недостатки.</p>
<p>Использую я его как и планировал - получаю список процессов в контейнере в
случае сообщений от мониторинга, и вывожу вместе с алертом. Теперь сообщение
из начала статьи, которое и побудило меня к написанию своего сервиса,
выглядит примерно так:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">CheckDockerStats WARNING: 83.32% CPU used!
 USER   PID  %CPU  %MEM      VSZ      RSS   STAT COMMAND
<span style="color:#ae81ff">65534</span>  <span style="color:#ae81ff">1285</span>  18.3   0.0    <span style="color:#ae81ff">18396</span>     <span style="color:#ae81ff">1632</span>      S /usr/sbin/nutcracker -v <span style="color:#ae81ff">11</span> -c /etc/twemproxy/config.yml
 <span style="color:#ae81ff">1000</span> <span style="color:#ae81ff">24891</span>   7.5   1.4   <span style="color:#ae81ff">299524</span>    <span style="color:#ae81ff">99200</span>      S python /path/to/program.py
 <span style="color:#ae81ff">1000</span>  <span style="color:#ae81ff">4474</span>   7.4   1.4   <span style="color:#ae81ff">303356</span>   <span style="color:#ae81ff">103416</span>      S python /path/to/program.py
 <span style="color:#ae81ff">1000</span>  <span style="color:#ae81ff">4468</span>   7.4   1.4   <span style="color:#ae81ff">301416</span>   <span style="color:#ae81ff">101228</span>      S python /path/to/program.py
 <span style="color:#ae81ff">1000</span>  <span style="color:#ae81ff">4475</span>   7.4   2.5   <span style="color:#ae81ff">382636</span>   <span style="color:#ae81ff">181792</span>      S python /path/to/program.py
</code></pre></div><p>Проверки использования ресурсов в контейнерах, пример вывода которых я
привел выше, я делаю все
<a href="https://github.com/abulimov/utils/blob/master/nagios/check_cadvisor.py">тем же скриптом check_cadvisor.py</a>,
только слегка доработанным для получения данных о процессах от cAdvisor-companion.</p>
<p>Ну а теперь о недостатках:</p>
<ul>
<li>мы видим не PID процесса в контейнере, а PID процесса в родительской системе</li>
<li>%CPU, который мы получаем от cAdvisor-companion, это <em>относительный процент
использования CPU в контейнере</em>. Чтобы было понятнее - мы вычисляем то,
какой процент из <em>всего</em> процессорного времени, использованного за некий
<em>interval</em> контейнером, использовал конкретный процесс, в то время как ps и top
показывает то, какой процент <em>доступного</em> процессорного времени использовал
процесс за тот же <em>interval</em>.</li>
</ul>
<p>Несмотря на перечисленные недостатки, сервис со своей задачей справляется,
так что если хотите обогатить сообщения от мониторинга полезным контекстом</p>
<ul>
<li>попробуйте <a href="https://github.com/abulimov/cadvisor-companion">cAdvisor-companion</a>
в паре с <a href="https://github.com/abulimov/utils/blob/master/nagios/check_cadvisor.py">check_cadvisor.py</a>,
это очень легко и абсолютно безопасно - при запуске в виде контейнера он получает
только read-only доступ к <code>/proc</code>.</li>
</ul>

</main>


<p class="terms">
<b>Tags:</b>

  <a href="//bulimov.ru/tags/golang/">Golang</a>

  <a href="//bulimov.ru/tags/cadvisor/">cAdvisor</a>

  <a href="//bulimov.ru/tags/cadvisor-companion/">cAdvisor-companion</a>

  <a href="//bulimov.ru/tags/%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">Программирование</a>

  <a href="//bulimov.ru/tags/monitoring/">Monitoring</a>


</p>
<p class="terms">

<b>Categories:</b>

  <a href="//bulimov.ru/categories/it/">IT</a>

  <a href="//bulimov.ru/categories/russian/">Russian</a>


</p>

  <footer>
  
  
  <hr/>
  <a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" alt="License: CC BY-SA 4.0"></a> © <a href="http://bulimov.ru">Alexander Bulimov</a> 2013 &ndash; 2021 | <a href="https://github.com/abulimov">Github</a>
  
  </footer>
  </body>
</html>

