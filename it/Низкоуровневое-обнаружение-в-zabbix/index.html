<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Низкоуровневое обнаружение в Zabbix | Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="https://models.bulimov.me">Scale Models</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/reviews/">Reviews</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Низкоуровневое обнаружение в Zabbix</span></h1>

<h2 class="date">2013/06/26</h2>

</div>

<main>
<p>В используемой мной системе мониторинга Zabbix, начиная с версии 2.0,
появилась такая любопытная штука, как <a href="https://www.zabbix.com/documentation/ru/2.0/manual/discovery/low_level_discovery">низкоуровневое обнаружение</a></p>
<p>Я не буду пересказывать содержимое документации, расскажу лучше о том, как я писал свой тип
обнаружения для мониторинга очередей RabbitMQ.</p>
<p>Проблема в том, что очередей в RabbitMQ может быть много, и, по мере развития веб-проекта,
они меняются. Так что я решил обнаруживать их автоматически, и написал для этого свой провайдер
данных для обнаружения заббикса.</p>
<p>Порядок действий прост:</p>
<ol>
<li>Получаем список vhostов командой <code>rabbitmqctl -q list_vhosts name</code></li>
<li>Получаем для каждого vhost список очередей командой <code>rabbitmqctl -q list_queues -p %vhost name</code></li>
<li>Отдаем полученные пары vhost:queue в формате JSON</li>
<li>Используем полученные данные в шаблонах заббикса, в разделе <em>обнаружение</em></li>
<li>PROFIT!</li>
</ol>
<p>На выходе должны получить что-то вроде этого:</p>
<pre><code>:::json
{
  &quot;data&quot;: [
    {&quot;{#RABBITMQ_VHOST_NAME}&quot;: &quot;/&quot;, &quot;{#RABBITMQ_QUEUE_NAME}&quot;: &quot;hello&quot;},
    {&quot;{#RABBITMQ_VHOST_NAME}&quot;: &quot;/&quot;, &quot;{#RABBITMQ_QUEUE_NAME}&quot;: &quot;world&quot;}
  ]
}
</code></pre>
<p>Реализовано все на Python, код предельно прост, в комментариях не нуждается.</p>
<p><strong>rabbitmq_discovery.py</strong></p>
<pre><code>:::python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import subprocess
import sys
import json

def _run(cmd):
    # returns (rc, stdout, stderr) from shell command
    process = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE, shell=True)
    stdout, stderr = process.communicate()
    return (process.returncode, stdout, stderr)

def parse_vhosts(data):
    vhosts = []
    for line in data.splitlines():
        vhosts.append(line.strip())
    return vhosts

def parse_stat(data, vhost):
    stat = []
    for line in data.splitlines():
        stat.append({
            '{#RABBITMQ_VHOST_NAME}': vhost,
            '{#RABBITMQ_QUEUE_NAME}': line.strip(),
        })
    return stat

def _fail(msg):
    print(msg)
    sys.exit(1)


def main():
    rc, raw_data, err = _run(&quot;rabbitmqctl -q list_vhosts name&quot;)
    if rc != 0:
        _fail(&quot;rabbitmqctl command failed with %s &quot;%err)
    vhosts = parse_vhosts(raw_data)

    raw_stats = []
    for vhost_name in vhosts:
        rc, raw_data, err = _run(&quot;rabbitmqctl -q list_queues -p %s name&quot;%vhost_name)
        if rc != 0:
        _fail(&quot;rabbitmqctl command failed with %s &quot;%err)
        raw_stats = raw_stats + parse_stat(raw_data, vhost_name)

    data = {
        'data': raw_stats
    }
    print json.dumps(data)

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<p>Еще нужно создать ключ, по которому заббикс будет всю эту красоту получать.</p>
<p>В конфиге заббикса добавляем что-либо вида</p>
<pre><code>UserParameter=rabbitmq.discovery,sudo /opt/rabbitmq_discovery.py
</code></pre>
<p>В моем случае, нужно беспарольное sudo на эту команду для пользователя Zabbix.</p>
<p>Ну а в самом заббиксе уже создаем в шаблоне обнаружение, в котором используем ключ
<code>rabbitmq.discovery</code> и макросы {#RABBITMQ_VHOST_NAME} и {#RABBITMQ_QUEUE_NAME}.
Это подробно описано в документации,
так что я этого описывать не буду.</p>
<p>Исходники доступны в моем <a href="https://github.com/abulimov/utils">репозитории</a>, в папке <em><code>zabbix/data_collectors</code></em>.</p>

</main>


<p class="terms">
<b>Tags:</b>

  <a href="//bulimov.me/tags/zabbix/">Zabbix</a>

  <a href="//bulimov.me/tags/python/">Python</a>

  <a href="//bulimov.me/tags/monitoring/">Monitoring</a>


</p>
<p class="terms">

<b>Categories:</b>

  <a href="//bulimov.me/categories/it/">IT</a>

  <a href="//bulimov.me/categories/russian/">Russian</a>


</p>

  <footer>
  
  
  <hr/>
  <a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" alt="License: CC BY-SA 4.0"></a> © <a href="http://bulimov.me">Alexander Bulimov</a> 2013 &ndash; 2022 | <a href="https://github.com/abulimov">Github</a>
  
  </footer>
  </body>
</html>

