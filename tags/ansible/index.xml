<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ansible on Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link>//bulimov.me/tags/ansible/</link>
    <description>Recent content in Ansible on Alexander Bulimov: Production Engineer and Scale Modeller</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 13 Nov 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="//bulimov.me/tags/ansible/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Удобная настройка Sensu с Ansible</title>
      <link>//bulimov.me/it/ansible-sensu/</link>
      <pubDate>Thu, 13 Nov 2014 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/ansible-sensu/</guid>
      <description>&lt;p&gt;Так как я использую &lt;a href=&#34;http://sensuapp.org/&#34;&gt;Sensu&lt;/a&gt; для мониторинга,&#xA;и &lt;a href=&#34;http://www.ansible.com/&#34;&gt;Ansible&lt;/a&gt; для управления конфигурациями,&#xA;то конечно же я настраиваю Sensu с помощью Ansible.&lt;/p&gt;&#xA;&lt;p&gt;В этой связке меня смущало только одно - Sensu использует&#xA;&lt;a href=&#34;https://ru.wikipedia.org/wiki/JSON&#34;&gt;JSON&lt;/a&gt; для конфигов,&#xA;в то время как Ansible использует &lt;a href=&#34;https://ru.wikipedia.org/wiki/YAML&#34;&gt;YAML&lt;/a&gt;.&#xA;Поскольку JSON является подмножеством YAML, и описывать&#xA;конфигурации в YAML гораздо проще (никаких проблем с запятыми, скобочками),&#xA;хотелось писать в YAML и транслировать в JSON.&lt;/p&gt;&#xA;&lt;p&gt;Начал я, конечно, с использования шаблонов Ansible:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;:::json&#xA;{&#xA;    &amp;quot;client&amp;quot;: {&#xA;        &amp;quot;address&amp;quot;: &amp;quot;{{ ansible_default_ipv4.address }}&amp;quot;,&#xA;        &amp;quot;name&amp;quot;: &amp;quot;{{ ansible_hostname }}&amp;quot;,&#xA;        &amp;quot;subscriptions&amp;quot;: [ &amp;quot;{{ sensu_client_subscriptions|join(&#39;&amp;quot;, &amp;quot;&#39;) }}&amp;quot; ]&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Вроде неплохо, но не слишком удобно, и если одним клиентам захочется добавить&#xA;что-то, например переменную &lt;code&gt;some_var&lt;/code&gt;, надо для них делать новый шаблон, или&#xA;городить строки такого вида:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Инфраструктура как код</title>
      <link>//bulimov.me/it/infrastructure-as-a-code/</link>
      <pubDate>Mon, 29 Sep 2014 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/infrastructure-as-a-code/</guid>
      <description>&lt;p&gt;Есть такой тренд сейчас - работать с IT-инфраструктурой как с кодом.&#xA;Хорошо цель этого метода описывается этой цитатой:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;“Enable the reconstruction of the business from nothing but a source code repository, an application data backup, and bare metal resources”&lt;/p&gt;&#xA;&lt;p&gt;&amp;ndash; Jesse Robins&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;Я полностью поддерживаю эту идею, причем именно в этой трактовке.&lt;/p&gt;&#xA;&lt;p&gt;Если говорить про парадигму, которую нам предлагает этот метод, то вот она:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Поддерживать модульную, легко поддающуюся автоматизации инфраструктуру,&#xA;и &lt;em&gt;описывать&lt;/em&gt; эту инфраструктуру с помощью языка высокого уровня.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Модуль zabbix_maintenance</title>
      <link>//bulimov.me/it/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C-zabbix_maintenance/</link>
      <pubDate>Mon, 11 Aug 2014 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C-zabbix_maintenance/</guid>
      <description>&lt;p&gt;Свершилось чудо, и мой &lt;a href=&#34;https://github.com/ansible/ansible/blob/devel/library/monitoring/zabbix_maintenance&#34;&gt;модуль&lt;/a&gt;&#xA;для Ansible, который умеет создавать и удалять периоды &amp;ldquo;в обслуживании&amp;rdquo; в Zabbix,&#xA;наконец-то &lt;a href=&#34;https://github.com/ansible/ansible/pull/5062&#34;&gt;приняли&lt;/a&gt; в апстрим.&#xA;Это уже третий мой модуль, принятый в апстрим Ansible.&lt;/p&gt;&#xA;&lt;p&gt;Краткая история:&lt;/p&gt;&#xA;&lt;p&gt;Модуль этот я запушил еще в 26 ноября 2013 года, но 21 декабря&#xA;&lt;a href=&#34;https://github.com/cove&#34;&gt;cove&lt;/a&gt; написал в комментарии к моему модулю,&#xA;что планирует выложить целую &lt;a href=&#34;https://github.com/ansible/ansible/pull/6034&#34;&gt;пачку&lt;/a&gt;&#xA;модулей для взаимодействия с Zabbix из Ansible.&#xA;Это отложило принятие моего модуля в апстрим почти на 9 месяцев,&#xA;поскольку мы согласовывали интерфейс наших модулей, тестировали и улучшали модули,&#xA;выложенные cove, а очередь pull-requestов у Ansible выросла до 300+.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ansible и serverspec</title>
      <link>//bulimov.me/it/ansible-%D0%B8-serverspec/</link>
      <pubDate>Thu, 22 May 2014 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/ansible-%D0%B8-serverspec/</guid>
      <description>&lt;p&gt;Когда я готовил playbook для &lt;a href=&#34;//bulimov.me/it/%D0%9B%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-vps&#34;&gt;своего VPS&lt;/a&gt;, я взял за основу&#xA;&lt;a href=&#34;https://github.com/al3x/sovereign&#34;&gt;Sovereign&lt;/a&gt;. В этом репозитории меня&#xA;заинтересовал файл &lt;strong&gt;tests.py&lt;/strong&gt;, содержащий тесты для результирующего сервера.&#xA;У меня сразу же возник вопрос - почему тесты самописные, на голом Python, а&#xA;не на каком-нибудь готовом решении. Я решил изучить, что же есть сейчас для&#xA;TDD-администрирования. Оказалось, что толком ничего и нет, а то, что&#xA;есть - для Ansible не особо нужно.&lt;/p&gt;&#xA;&lt;p&gt;Для начала, что есть. Тут все скучно, есть &lt;a href=&#34;http://serverspec.org/&#34;&gt;serverspec&lt;/a&gt;,&#xA;и &lt;a href=&#34;https://pypi.python.org/pypi/envassert&#34;&gt;&lt;code&gt;envassert&lt;/code&gt;&lt;/a&gt;. Оба эти инструмента&#xA;предоставляют возможность декларативно описать требуемое состояние удаленного&#xA;сервера, и проверить его соответствие реальности по ssh.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Тестирование Ansible Playbook</title>
      <link>//bulimov.me/it/%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-ansible-playbook/</link>
      <pubDate>Thu, 13 Mar 2014 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-ansible-playbook/</guid>
      <description>&lt;p&gt;Давно хотел сделать авто-тестирование целостности развертывания, производимого&#xA;с помощью &lt;a href=&#34;http://ansible.com&#34;&gt;Ansible&lt;/a&gt;. Чтобы, значит, запушил я новую версию плейбука в репозитория,&#xA;и CI проверила работоспособность системы. Причем не просто корректность синтаксиса,&#xA;а работоспособность проводимого деплоя.&lt;/p&gt;&#xA;&lt;p&gt;Вот наконец до этого дошли руки.&lt;/p&gt;&#xA;&lt;p&gt;Точнее, руки до этого дошли еще в середине 2013 года, но тогда я собрал все это&#xA;с помощью стройной системы костылей, взяв за основу заранее минимально&#xA;сконфигуренные qemu-образы на LVM-снапшотах.&lt;/p&gt;&#xA;&lt;p&gt;Теперь я решил подойти к вопросу серьезнее, взять общепринятые инструменты&#xA;и избавиться от костылей.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Как я управляю серверами</title>
      <link>//bulimov.me/it/%D0%9A%D0%B0%D0%BA-%D1%8F-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0%D0%BC%D0%B8/</link>
      <pubDate>Thu, 05 Sep 2013 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/%D0%9A%D0%B0%D0%BA-%D1%8F-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0%D0%BC%D0%B8/</guid>
      <description>&lt;p&gt;Решил вот описать принципы управления серверами, к которым пришел за эти 3 года.&lt;/p&gt;&#xA;&lt;p&gt;Итак:&lt;/p&gt;&#xA;&lt;h3 id=&#34;принцип-1&#34;&gt;принцип №1&lt;/h3&gt;&#xA;&lt;p&gt;Все конфиги лежат в &lt;a href=&#34;http://en.wikipedia.org/wiki/Revision_control&#34;&gt;VCS&lt;/a&gt;, я сейчас использую Git.&#xA;Я думаю, в комментариях принцип не нуждается, необходимость централизованного&#xA;хранения конфигов, а также хранения истории изменений с возможностью отката обсуждалась не раз.&lt;/p&gt;&#xA;&lt;h3 id=&#34;принцип-2&#34;&gt;принцип №2&lt;/h3&gt;&#xA;&lt;p&gt;Все ПО ставится только из пакетов, никаких ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install.&#xA;Если пакета нужной версии нет в репозиториях дистрибутива - ищем готовый пакет, желательно&#xA;от разработчиков, или от солидного стороннего репозитория типа &lt;a href=&#34;http://www.dotdeb.org/&#34;&gt;dotdeb&lt;/a&gt;. Если пакета для ПО нет - собираем пакет сами,&#xA;причем процесс сборки документируется, а все нужное для сборки кладется в VCS.&#xA;Все сторонние пакеты собираются в свой репозиторий, в котором как минимум есть разделение на stable и testing.&#xA;Все пакеты из testing, после проверки на стейджинге, перемещаются в stable.&#xA;Таким образом, мы контролируем установленное ПО средствами дистрибутива, что сильно упрощает жизнь сисадмина.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
