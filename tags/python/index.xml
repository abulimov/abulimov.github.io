<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link>//bulimov.me/tags/python/</link>
    <description>Recent content in Python on Alexander Bulimov: Production Engineer and Scale Modeller</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 02 Dec 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="//bulimov.me/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Snooping on unix domain sockets traffic</title>
      <link>//bulimov.me/post/2021/12/02/unix-socket-snoop/</link>
      <pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/post/2021/12/02/unix-socket-snoop/</guid>
      <description>&lt;p&gt;I often work with various binary protocol, with majority of work being implementing those protocols in Go or Rust.&lt;/p&gt;&#xA;&lt;p&gt;And when dealing with such tasks, I find it extremely useful to be able to snoop on&#xA;the traffic between existing/reference implementations.&lt;/p&gt;&#xA;&lt;p&gt;When communication happens over network (even locally), it&amp;rsquo;s easy - just fire up some&#xA;good old &lt;code&gt;tcpdump&lt;/code&gt; and then maybe analyze the dump with Wireshark.&lt;/p&gt;&#xA;&lt;p&gt;But what if communication happens over the &lt;a href=&#34;https://man7.org/linux/man-pages/man7/unix.7.html&#34;&gt;Unix domain sockets&lt;/a&gt;?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python is not good for production</title>
      <link>//bulimov.me/post/2021/03/13/python-rewrite/</link>
      <pubDate>Sat, 13 Mar 2021 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/post/2021/03/13/python-rewrite/</guid>
      <description>&lt;p&gt;Here, I said it.&lt;/p&gt;&#xA;&lt;p&gt;Recently I read an excellent (opinionated) &lt;a href=&#34;http://rachelbythebay.com/w/2021/02/22/lang/&#34;&gt;post by rachelbythebay&lt;/a&gt; describing&#xA;things she cannot stand in programming language, and it resonated deeply with me and finally pushed me to write this.&lt;/p&gt;&#xA;&lt;p&gt;I feel quite strongly about using Python in production, and below I&amp;rsquo;ll summarize my experience and opinion.&lt;/p&gt;&#xA;&lt;p&gt;Everyone is entitled to their own opinion, this is mine.&lt;/p&gt;&#xA;&lt;p&gt;I&amp;rsquo;m not trying to offend anyone, so if you love Python - maybe try to see my side of things.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python 3.6 f-strings rant</title>
      <link>//bulimov.me/it/python3-fstrings/</link>
      <pubDate>Mon, 24 Jul 2017 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/python3-fstrings/</guid>
      <description>&lt;p&gt;Python 3.6 introduced a new way to format strings, called&#xA;&lt;a href=&#34;https://docs.python.org/3.6/reference/lexical_analysis.html#f-strings&#34;&gt;&lt;strong&gt;Formatted string literals&lt;/strong&gt;&lt;/a&gt;,&#xA;or just &lt;em&gt;f-strings&lt;/em&gt;. Everyone on the internet&#xA;seem to be happy about it. I&amp;rsquo;m definitely not.&lt;/p&gt;&#xA;&lt;p&gt;For starters, Python 3 already had 3 built-in ways of doing it before.&#xA;Just think about it&amp;hellip; 3 ways to &lt;em&gt;format strings&lt;/em&gt; in language that declares simplicity as a goal:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;There should be one&amp;ndash; and preferably only one &amp;ndash;obvious way to do it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python Type Hints are awesome</title>
      <link>//bulimov.me/it/python-typing/</link>
      <pubDate>Thu, 12 May 2016 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/python-typing/</guid>
      <description>&lt;p&gt;I really love &lt;a href=&#34;http://jvns.ca&#34;&gt;Julia Evans&amp;rsquo;s blog&lt;/a&gt;, she writes with such excitement&#xA;and enthusiasm about every new bit of technology she learns. For me, this is what&#xA;makes our job so great - we can learn something new and cool almost every day.&lt;/p&gt;&#xA;&lt;p&gt;And recently I&amp;rsquo;ve felt very excited with some of new abilities Python&#xA;now have. I&amp;rsquo;m talking about including of &lt;a href=&#34;https://www.python.org/dev/peps/pep-0484/&#34;&gt;PEP 484&lt;/a&gt;,&#xA;which describes Type Hints, in Python 3.5 (old news, I know).&lt;/p&gt;</description>
    </item>
    <item>
      <title>О пользе Python и костылях с Docker</title>
      <link>//bulimov.me/it/delete-docker-registry-image/</link>
      <pubDate>Wed, 02 Mar 2016 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/delete-docker-registry-image/</guid>
      <description>&lt;p&gt;В процессе организации авто-очистки &lt;a href=&#34;https://github.com/docker/distribution&#34;&gt;Docker Registry 2&lt;/a&gt;,&#xA;устав ждать в появления в нем столь &amp;ldquo;ненужного&amp;rdquo; функционала, как удаление образов&#xA;с диска (DELETE запросы удаляют тег, но сами данные остаются на диске и жрут место),&#xA;я в очередной раз прибег к помощи скрипта из&#xA;&lt;a href=&#34;https://github.com/burnettk/delete-docker-registry-image&#34;&gt;delete-docker-registry-image&lt;/a&gt;,&#xA;и уперся в то, что этот самый скрипт (написанный изначально на bash) невероятно&#xA;медленно работает на большом Registry.&lt;/p&gt;&#xA;&lt;p&gt;К примеру, удаления одного тега для repository с 70 тегами, в каждом из которых&#xA;много слоев, занимает &lt;strong&gt;49 минут&lt;/strong&gt;. А мне надо удалить 60 старых тегов из 70.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Плагин к collectd для сбора метрик Riak CS</title>
      <link>//bulimov.me/it/collectd-riakcs/</link>
      <pubDate>Thu, 17 Sep 2015 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/collectd-riakcs/</guid>
      <description>&lt;p&gt;На днях наконец-то дошли руки до модернизации той части мониторинга, которая&#xA;отвечает за сбор метрик, и набивший оскомину &lt;a href=&#34;http://munin-monitoring.org&#34;&gt;Munin&lt;/a&gt; был&#xA;окончательно заменен на &lt;a href=&#34;https://graphite.readthedocs.org/en/latest/&#34;&gt;Graphite&lt;/a&gt; + &lt;a href=&#34;http://collectd.org&#34;&gt;CollectD&lt;/a&gt;.&#xA;Теперь воцарилась идиллия - Icinga2 складывает метрики из perfdata в Graphite,&#xA;и CollectD отправляет все метрики туда же.&lt;/p&gt;&#xA;&lt;p&gt;Хочется отдельно отметить, что несмотря на то, что изначально CollectD мне&#xA;не очень понравился (кому может сейчас понравиться Apache-подобный конфиг?), при&#xA;дальнейшем изучении я был приятно поражен богатством возможностей этого&#xA;продукта и крайне бережным его отношением к ресурсам наблюдаемой системы.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Балансировка в HAProxy на основе данных cAdvisor</title>
      <link>//bulimov.me/it/haproxy-cadvisor/</link>
      <pubDate>Wed, 15 Apr 2015 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/haproxy-cadvisor/</guid>
      <description>&lt;p&gt;Для запуска Docker-контейнеров у меня в данный момент выделено достаточно много&#xA;серверов, причем аппаратная часть у некоторых из них отличается&#xA;друг от друга. Соответственно, при настройке на чудесном балансировщике&#xA;&lt;a href=&#34;http://www.haproxy.org/&#34;&gt;HAProxy&lt;/a&gt; такого параметра балансировки&#xA;как &lt;em&gt;&amp;ldquo;вес сервера&amp;rdquo;&lt;/em&gt;, приходится это различие в аппаратной части учитывать.&lt;/p&gt;&#xA;&lt;p&gt;Можно, конечно, подобрать значения весов самостоятельно на основе&#xA;данных мониторинга, а при появлении нагрузки от соседних Docker-контейнеров&#xA;эти веса корректировать, но это не наш метод.&lt;/p&gt;&#xA;&lt;p&gt;Не так давно я &lt;a href=&#34;//bulimov.me/it/check-cadvisor&#34;&gt;писал&lt;/a&gt; о том, как использую данные из&#xA;&lt;a href=&#34;https://github.com/google/cadvisor&#34;&gt;cAdvisor&lt;/a&gt; для мониторинга нагруженности&#xA;контейнеров.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Мониторим Docker-контейнеры с cAdvisor и Nagios/Icinga2</title>
      <link>//bulimov.me/it/check-cadvisor/</link>
      <pubDate>Fri, 20 Feb 2015 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/check-cadvisor/</guid>
      <description>&lt;p&gt;После того, как я &lt;a href=&#34;//bulimov.me/it/check-docker-memory&#34;&gt;научился мониторить память в Docker-контейнерах&lt;/a&gt;,&#xA;я решил мониторить еще и нагрузку на CPU.&#xA;Поскольку это дело не самое тривиальное, и хотелось не писать свой&#xA;велосипед, а пользоваться чем-то популярным и поддерживаемым, я решил&#xA;попробовать &lt;a href=&#34;https://github.com/google/cadvisor&#34;&gt;cAdvisor&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;И вот что я могу сказать - отличный инструмент!&#xA;Ресурсов практически не потребляет (около 20 Мб оперативной памяти и&#xA;неизмеримо мало CPU), обладает простым API для доступа к собираемой им&#xA;информации, имеет красивый веб-интерфейс с realtime-графиками.&#xA;А еще умеет сам писать метрики в Influxdb, и в будущем &lt;a href=&#34;https://github.com/google/cadvisor/issues/474&#34;&gt;научится писать&#xA;в Graphite&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Научился мониторить использование памяти в Docker-контейнерах</title>
      <link>//bulimov.me/it/check-docker-memory/</link>
      <pubDate>Fri, 13 Feb 2015 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/check-docker-memory/</guid>
      <description>&lt;p&gt;Я сегодня занимался мониторингом, а конкретно нашими докер-контейнерами.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;Лирическое отступление:&#xA;Для мониторинга я теперь (уже на другом месте работы) использую&#xA;наследника Nagios - &lt;a href=&#34;https://www.icinga.org/icinga/icinga-2/&#34;&gt;Icinga2&lt;/a&gt;.&#xA;Пока все нравится, ребята очень круто переписали Nagios, реализовали гораздо&#xA;более вменяемый формат конфигурации, и кучу новых возможностей.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;Используя Docker для автотестов я уже ловил проблемы, когда интерпретатор Ruby&#xA;кушал всю выделенную память в контейнере и тихо умирал от рук OOM Killer.&lt;/p&gt;&#xA;&lt;p&gt;Поскольку теперь я использую &lt;a href=&#34;http://docker.io&#34;&gt;Docker&lt;/a&gt; уже не только для тестов,&#xA;но и &amp;ldquo;в бою&amp;rdquo;, меня сильно беспокоило то, что мы не можем мониторить&#xA;использование памяти внутри контейнера.&#xA;А не можем мы этого делать потому, что все утилиты (free, top) и плагины мониторинга&#xA;используют данные из /proc/meminfo, которые внутри контейнеров&#xA;&lt;a href=&#34;http://fabiokung.com/2014/03/13/memory-inside-linux-containers/&#34;&gt;не актуальны&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lyrics Tagger</title>
      <link>//bulimov.me/it/lyricstagger/</link>
      <pubDate>Tue, 25 Nov 2014 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/lyricstagger/</guid>
      <description>&lt;h2 id=&#34;предыстория&#34;&gt;Предыстория&lt;/h2&gt;&#xA;&lt;p&gt;Я езжу на работу в общественном транспорте, и слушаю там музыку&#xA;со смартфона. Достаточно часто хотелось почитать тексты прослушиваемых&#xA;в данный момент песен, но искать их в интернете было не слишком удобно,&#xA;да и вообще интернета до недавнего времени в метро не было.&lt;/p&gt;&#xA;&lt;p&gt;Решение выглядит очевидным - надо встроить тексты песен в сами музыкальные файлы.&#xA;Благо, основные форматы это позволяют.&#xA;Музыку я храню во &lt;a href=&#34;https://ru.wikipedia.org/wiki/FLAC&#34;&gt;FLAC&lt;/a&gt;, а на смартфон&#xA;закидываю в &lt;a href=&#34;https://ru.wikipedia.org/wiki/Vorbis&#34;&gt;Ogg Vorbis&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Разбирался с page-cache в Linux</title>
      <link>//bulimov.me/it/meminfo-visualizer/</link>
      <pubDate>Thu, 09 Oct 2014 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/meminfo-visualizer/</guid>
      <description>&lt;p&gt;Читая книгу &lt;a href=&#34;http://www.williamspublishing.com/Books/5-8459-1085-4.html&#34;&gt;&amp;ldquo;Разработка ядра Linux&amp;rdquo;&lt;/a&gt; за авторством Роберта Лава,&#xA;я решил поглубже разобраться в том, как работает кэш в Linux,&#xA;и набрел на вот &lt;a href=&#34;http://habrahabr.ru/company/yandex/blog/231957/&#34;&gt;эту&lt;/a&gt;&#xA;статью на Хабре от Яндекса.&lt;/p&gt;&#xA;&lt;p&gt;Сама статья весьма познавательна, особенно видео - рекомендую.&#xA;Так вот, в этом видео &lt;em&gt;Роман Гущин&lt;/em&gt;, с помощью простой утилиты, наглядно показывающей&#xA;размер кэша, показывал как работает файловый кэш.&lt;/p&gt;&#xA;&lt;p&gt;Конечно, мне захотелось в образовательных целях написать такую утилиту для себя,&#xA;чтобы можно было поиграться с кэшем и видеть изменения.&lt;/p&gt;</description>
    </item>
    <item>
      <title>s/Ruhoh/Pelican/</title>
      <link>//bulimov.me/it/from-ruhoh-to-pelican/</link>
      <pubDate>Thu, 25 Sep 2014 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/from-ruhoh-to-pelican/</guid>
      <description>&lt;p&gt;Переехал с &lt;a href=&#34;http://ruhoh.com&#34;&gt;Ruhoh&lt;/a&gt; на &lt;a href=&#34;http://getpelican.com&#34;&gt;Pelican&lt;/a&gt;,&#xA;потому что Python.&lt;/p&gt;&#xA;&lt;p&gt;А если подробнее - потому что Ruhoh написан на Ruby, и не особо развивается.&#xA;А Pelican написан на Python, который является моим основным языком,&#xA;и уже давно и активно развивается, и обладает обширной базой&#xA;&lt;a href=&#34;https://github.com/getpelican/pelican-plugins&#34;&gt;плагинов&lt;/a&gt; и&#xA;&lt;a href=&#34;https://github.com/getpelican/pelican-themes&#34;&gt;тем&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Выложил немного полезностей</title>
      <link>//bulimov.me/it/%D0%92%D1%8B%D0%BB%D0%BE%D0%B6%D0%B8%D0%BB-%D0%BD%D0%B5%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9/</link>
      <pubDate>Wed, 17 Sep 2014 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/%D0%92%D1%8B%D0%BB%D0%BE%D0%B6%D0%B8%D0%BB-%D0%BD%D0%B5%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9/</guid>
      <description>&lt;p&gt;Когда я писал про то, как &lt;a href=&#34;//bulimov.me/it/%D0%9F%D0%B5%D1%80%D0%B5%D0%BF%D0%B8%D1%81%D0%B0%D0%BB-%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D1%8B-%D0%BD%D0%B0-ruby-%D0%B4%D0%BB%D1%8F-sensu&#34;&gt;переписал скрипты для Sensu&lt;/a&gt;,&#xA;я слегка слукавил. Изначально, я написал эти скрипты на Python,&#xA;и только потом на Ruby. Поскольку пользователям других Nagios-совместимых&#xA;систем мониторинга может показаться неудобным использование ruby-скриптов,&#xA;да еще и с зависимостью от гема Sensu-plugin, я решил выложить&#xA;и Python-версии скриптов.&lt;/p&gt;&#xA;&lt;p&gt;Если кому хочется мониторить состояние дисков в raid-контроллерах от 3ware или&#xA;HP SmartArray на чистом Python - милости просим, все&#xA;&lt;a href=&#34;https://github.com/abulimov/utils/tree/master/nagios&#34;&gt;в моем репозитории&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Модуль zabbix_maintenance</title>
      <link>//bulimov.me/it/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C-zabbix_maintenance/</link>
      <pubDate>Mon, 11 Aug 2014 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C-zabbix_maintenance/</guid>
      <description>&lt;p&gt;Свершилось чудо, и мой &lt;a href=&#34;https://github.com/ansible/ansible/blob/devel/library/monitoring/zabbix_maintenance&#34;&gt;модуль&lt;/a&gt;&#xA;для Ansible, который умеет создавать и удалять периоды &amp;ldquo;в обслуживании&amp;rdquo; в Zabbix,&#xA;наконец-то &lt;a href=&#34;https://github.com/ansible/ansible/pull/5062&#34;&gt;приняли&lt;/a&gt; в апстрим.&#xA;Это уже третий мой модуль, принятый в апстрим Ansible.&lt;/p&gt;&#xA;&lt;p&gt;Краткая история:&lt;/p&gt;&#xA;&lt;p&gt;Модуль этот я запушил еще в 26 ноября 2013 года, но 21 декабря&#xA;&lt;a href=&#34;https://github.com/cove&#34;&gt;cove&lt;/a&gt; написал в комментарии к моему модулю,&#xA;что планирует выложить целую &lt;a href=&#34;https://github.com/ansible/ansible/pull/6034&#34;&gt;пачку&lt;/a&gt;&#xA;модулей для взаимодействия с Zabbix из Ansible.&#xA;Это отложило принятие моего модуля в апстрим почти на 9 месяцев,&#xA;поскольку мы согласовывали интерфейс наших модулей, тестировали и улучшали модули,&#xA;выложенные cove, а очередь pull-requestов у Ansible выросла до 300+.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Низкоуровневое обнаружение в Zabbix, ищем диски в контроллере от 3ware</title>
      <link>//bulimov.me/it/%D0%9D%D0%B8%D0%B7%D0%BA%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%BE%D0%B5-%D0%BE%D0%B1%D0%BD%D0%B0%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-zabbix-%D0%B8%D1%89%D0%B5%D0%BC-%D0%B4%D0%B8%D1%81%D0%BA%D0%B8-%D0%B2-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D0%B5-%D0%BE%D1%82-3ware/</link>
      <pubDate>Wed, 14 Aug 2013 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/%D0%9D%D0%B8%D0%B7%D0%BA%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%BE%D0%B5-%D0%BE%D0%B1%D0%BD%D0%B0%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-zabbix-%D0%B8%D1%89%D0%B5%D0%BC-%D0%B4%D0%B8%D1%81%D0%BA%D0%B8-%D0%B2-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D0%B5-%D0%BE%D1%82-3ware/</guid>
      <description>&lt;p&gt;Я уже &lt;a href=&#34;//bulimov.me/it/%D0%9D%D0%B8%D0%B7%D0%BA%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%BE%D0%B5-%D0%BE%D0%B1%D0%BD%D0%B0%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-zabbix&#34;&gt; писал &lt;/a&gt; про &lt;a href=&#34;https://www.zabbix.com/documentation/ru/2.0/manual/discovery/low_level_discovery&#34;&gt;низкоуровневое обнаружение&lt;/a&gt;&#xA;в Zabbix, так что повторять теорию не буду.&lt;/p&gt;&#xA;&lt;p&gt;Теперь мне понадобилось автоматом получать список хардов в массивах&#xA;на контроллерах 3ware, которыми оборудованы у нас многие сервера.&lt;/p&gt;&#xA;&lt;p&gt;Вести руками шаблоны для каждого сервера с иным порядком или количеством дисков&#xA;показалось мне плохой идеей, да и авто-обнаружение само напрашивалось.&lt;/p&gt;&#xA;&lt;p&gt;Вдохновлялся я утилитой 3ware-status, для работы авто-обнаружения нам потребуется&#xA;установленная утилита tw-cli, взять ее для Debian/Ubuntu проще всего &lt;a href=&#34;http://hwraid.le-vert.net/&#34;&gt; здесь &lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Низкоуровневое обнаружение в Zabbix</title>
      <link>//bulimov.me/it/%D0%9D%D0%B8%D0%B7%D0%BA%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%BE%D0%B5-%D0%BE%D0%B1%D0%BD%D0%B0%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-zabbix/</link>
      <pubDate>Wed, 26 Jun 2013 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/%D0%9D%D0%B8%D0%B7%D0%BA%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%BE%D0%B5-%D0%BE%D0%B1%D0%BD%D0%B0%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-zabbix/</guid>
      <description>&lt;p&gt;В используемой мной системе мониторинга Zabbix, начиная с версии 2.0,&#xA;появилась такая любопытная штука, как &lt;a href=&#34;https://www.zabbix.com/documentation/ru/2.0/manual/discovery/low_level_discovery&#34;&gt;низкоуровневое обнаружение&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Я не буду пересказывать содержимое документации, расскажу лучше о том, как я писал свой тип&#xA;обнаружения для мониторинга очередей RabbitMQ.&lt;/p&gt;&#xA;&lt;p&gt;Проблема в том, что очередей в RabbitMQ может быть много, и, по мере развития веб-проекта,&#xA;они меняются. Так что я решил обнаруживать их автоматически, и написал для этого свой провайдер&#xA;данных для обнаружения заббикса.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
