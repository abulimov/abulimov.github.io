<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Программирование on Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link>//bulimov.ru/tags/%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/</link>
    <description>Recent content in Программирование on Alexander Bulimov: Production Engineer and Scale Modeller</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 15 Apr 2016 00:00:00 +0000</lastBuildDate><atom:link href="//bulimov.ru/tags/%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Утилита gotests и плагин для Atom</title>
      <link>//bulimov.ru/it/atom-gotests/</link>
      <pubDate>Fri, 15 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/atom-gotests/</guid>
      <description>Поскольку последнее время я все больше пишу на Go, мой workflow потихоньку обрастает различными полезными утилитами.
Одним из лучших открытий (после изумительного go-plus для Atom, который превращает Atom в полнофункциональную IDE для Go) стала утилита gotests, которая позволяет генерировать табличные тесты. При этом для нее есть плагины для Sublime Text 3 и Emacs.
Я большой сторонник юнит-тестирования, и потому возможность создавать шаблоны для тестов одной командой меня очень обрадовала.
Выглядит это как-то так:</description>
    </item>
    
    <item>
      <title>Все для HAProxy в Atom</title>
      <link>//bulimov.ru/it/atom-haproxy/</link>
      <pubDate>Fri, 08 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/atom-haproxy/</guid>
      <description>Появилась у меня на работе задачка - взять 3 относительно разных конфига HAProxy, ответвившихся когда-то от общего предка, и обратно унифицировать их в один.
Конфиги хорошие, большие - 800 строк каждый.
Приступил я к этой задаче, и сразу оступил - потому что в Atom, которым я пользуюсь для редактирования всего, не было подсветки синтаксиса конфигов HAProxy.
Ну у нас же тут opensource, так что тут же был нагуглен архив с HAProxy.</description>
    </item>
    
    <item>
      <title>Vendoring зависимостей в Go</title>
      <link>//bulimov.ru/it/go-vendoring/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/go-vendoring/</guid>
      <description>После недавнего удаления модуля на 11 строк кода из npm, которое сломало всю Node.js инфраструктуру, я по-новому взглянул на то, как в проектах на Go реализованы зависимости от других пакетов.
Изначально, при знакомстве с go я был крайне недоволен отсутствием возможности задавать зависимости от конкретных версий (зависимость указывается только от репозитория, т.е. от master ветки) - ведь апстрим может ломать обратную совместимость, и твой проект просто не соберется. Причем я сам с этой проблемой столкнулся, и это было очень неприятно.</description>
    </item>
    
    <item>
      <title>Открыл код db-checker</title>
      <link>//bulimov.ru/it/db-checker/</link>
      <pubDate>Fri, 18 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/db-checker/</guid>
      <description>Недавно я открыл код еще одного инструмента, который уже около года использую на работе - db-checker.
Началось все с необходимости проводить регулярные проверки логической целостности данных в БД. Проще говоря - гонять мониторингом запросы к базе.
Сначала это была часть проекта, который проверял данные на нашем CDN. Проект этот сразу планировался многопоточным, поэтому написан на Go. Затем мухи были отделены от котлет, и проверка базы выделилась в отдельную сущность, но несколько legacy-моментов осталось.</description>
    </item>
    
    <item>
      <title>О пользе Python и костылях с Docker</title>
      <link>//bulimov.ru/it/delete-docker-registry-image/</link>
      <pubDate>Wed, 02 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/delete-docker-registry-image/</guid>
      <description>В процессе организации авто-очистки Docker Registry 2, устав ждать в появления в нем столь &amp;ldquo;ненужного&amp;rdquo; функционала, как удаление образов с диска (DELETE запросы удаляют тег, но сами данные остаются на диске и жрут место), я в очередной раз прибег к помощи скрипта из delete-docker-registry-image, и уперся в то, что этот самый скрипт (написанный изначально на bash) невероятно медленно работает на большом Registry.
К примеру, удаления одного тега для repository с 70 тегами, в каждом из которых много слоев, занимает 49 минут.</description>
    </item>
    
    <item>
      <title>Рекомендую Advent Of Code</title>
      <link>//bulimov.ru/it/advent-of-code/</link>
      <pubDate>Thu, 11 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/advent-of-code/</guid>
      <description>Закончил на днях решать задачи из замечательного набора программерских пазлов Advent Of Code (да, я тормоз и даже пропустил начало этого конкурса), и могу уверенно рекомендовать его любому.
Задачки веселые, разнообразные, в меру сложные, содержат много классических задач (задача коммивояжёра, задача о ранце и т.д.) в занятной обертке, так что их решение дает возможность отлично размять мозги.
Так же эти задачки отлично подходят для изучения нового языка, чем я отчасти воспользовался - решал все на Go, освежив и укрепив свои знания.</description>
    </item>
    
    <item>
      <title>Плагин к Collectd для сбора метрик Riak CS</title>
      <link>//bulimov.ru/it/collectd-riakcs/</link>
      <pubDate>Thu, 17 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/collectd-riakcs/</guid>
      <description>На днях наконец-то дошли руки до модернизации той части мониторинга, которая отвечает за сбор метрик, и набивший оскомину Munin был окончательно заменен на Graphite + Collectd. Теперь воцарилась идиллия - Icinga2 складывает метрики из perfdata в Graphite, и Collectd отправляет все метрики туда же.
Хочется отдельно отметить, что несмотря на то, что изначально Collectd мне не очень понравился (кому может сейчас понравиться Apache-подобный конфиг?), при дальнейшем изучении я был приятно поражен богатством возможностей этого продукта и крайне бережным его отношением к ресурсам наблюдаемой системы.</description>
    </item>
    
    <item>
      <title>Улучшаем сообщения от мониторинга с помощью cAdvisor-companion</title>
      <link>//bulimov.ru/it/cadvisor-companion/</link>
      <pubDate>Tue, 21 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/cadvisor-companion/</guid>
      <description>Слышали ли вы когда-нибудь о такой практике, как &amp;ldquo;Monitoring Events Enrichment&amp;rdquo;? Если вкратце, то это практика наполнения дополнительной информацией сообщений от мониторинга, так что на выяснение причины проблемы уходит меньше времени и телодвижений.
Есть даже контора, которая помогает внедрять эту практику на коммерческой основе, у них на сайте есть неплохие примеры того, что и зачем можно добавить к обычному сообщению от Nagios.
Сама эта идея мне очень нравится, и вот после очередного неинформативного сообщения от мониторинга, которое пришло тогда, когда я был далеко от компьютера, и гласило CheckDockerStats CRITICAL: 91% CPU Used!</description>
    </item>
    
    <item>
      <title>Балансировка в HAProxy на основе данных cAdvisor</title>
      <link>//bulimov.ru/it/haproxy-cadvisor/</link>
      <pubDate>Wed, 15 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/haproxy-cadvisor/</guid>
      <description>Для запуска Docker-контейнеров у меня в данный момент выделено достаточно много серверов, причем аппаратная часть у некоторых из них отличается друг от друга. Соответственно, при настройке на чудесном балансировщике HAProxy такого параметра балансировки как &amp;ldquo;вес сервера&amp;rdquo;, приходится это различие в аппаратной части учитывать.
Можно, конечно, подобрать значения весов самостоятельно на основе данных мониторинга, а при появлении нагрузки от соседних Docker-контейнеров эти веса корректировать, но это не наш метод.
Не так давно я писал о том, как использую данные из cAdvisor для мониторинга нагруженности контейнеров.</description>
    </item>
    
    <item>
      <title>Lyrics Tagger</title>
      <link>//bulimov.ru/it/lyricstagger/</link>
      <pubDate>Tue, 25 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/lyricstagger/</guid>
      <description>Предыстория Я езжу на работу в общественном транспорте, и слушаю там музыку со смартфона. Достаточно часто хотелось почитать тексты прослушиваемых в данный момент песен, но искать их в интернете было не слишком удобно, да и вообще интернета до недавнего времени в метро не было.
Решение выглядит очевидным - надо встроить тексты песен в сами музыкальные файлы. Благо, основные форматы это позволяют. Музыку я храню во FLAC, а на смартфон закидываю в Ogg Vorbis.</description>
    </item>
    
    <item>
      <title>Разбирался с page-cache в Linux</title>
      <link>//bulimov.ru/it/meminfo-visualizer/</link>
      <pubDate>Thu, 09 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/meminfo-visualizer/</guid>
      <description>Читая книгу &amp;ldquo;Разработка ядра Linux&amp;rdquo; за авторством Роберта Лава, я решил поглубже разобраться в том, как работает кэш в Linux, и набрел на вот эту статью на Хабре от Яндекса.
Сама статья весьма познавательна, особенно видео - рекомендую. Так вот, в этом видео Роман Гущин, с помощью простой утилиты, наглядно показывающей размер кэша, показывал как работает файловый кэш.
Конечно, мне захотелось в образовательных целях написать такую утилиту для себя, чтобы можно было поиграться с кэшем и видеть изменения.</description>
    </item>
    
    <item>
      <title>О любви к программированию</title>
      <link>//bulimov.ru/it/%D0%9E-%D0%BB%D1%8E%D0%B1%D0%B2%D0%B8-%D0%BA-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E/</link>
      <pubDate>Thu, 25 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/%D0%9E-%D0%BB%D1%8E%D0%B1%D0%B2%D0%B8-%D0%BA-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E/</guid>
      <description>Хоть я и выбрал своей профессией системное администрирование, программирование я люблю. Даже очень люблю.
Вот решил написать историю моего знакомства с программированием.
###Школа
Началось все в школе. Одноклассник ходил на курсы программирования, готовясь поступать в какой-то технический вуз, и рассказывал про Delphi. Рассказы его так меня увлекли, что я даже сподобился установить этот самый Delphi, и даже создал какую-то форму, скопировав код из примеров, присланных одноклассником. По итогу этих действий, у меня сложилось впечатление, что программирование - это точно не для меня.</description>
    </item>
    
    <item>
      <title>Плагин к Ruhoh для рисования графиков</title>
      <link>//bulimov.ru/it/%D0%9F%D0%BB%D0%B0%D0%B3%D0%B8%D0%BD-%D0%BA-ruhoh-%D0%B4%D0%BB%D1%8F-%D1%80%D0%B8%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%BE%D0%B2/</link>
      <pubDate>Fri, 21 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>//bulimov.ru/it/%D0%9F%D0%BB%D0%B0%D0%B3%D0%B8%D0%BD-%D0%BA-ruhoh-%D0%B4%D0%BB%D1%8F-%D1%80%D0%B8%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%BE%D0%B2/</guid>
      <description>Еще планируя создание статического блога на Hakyll я хотел реализовать рисование графиков &amp;ldquo;на лету&amp;rdquo; из отдельно хранящихся данных. Но с Hakyll не сложилось, и после долгих поисков я остановился на Ruhoh.
Все нижеописанное относится к Ruhoh 2.1
###Цель
Рисовать графики из данных, хранящихся в человеко-читаемом виде. Нужно мне это было для визуализации своих спортивных тренировок.
###Решение
Конечно, я решил оформить все в виде плагина к Ruhoh, благо возможность такая есть, да и программировать я люблю.</description>
    </item>
    
  </channel>
</rss>
