<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chef on Alexander Bulimov: Production Engineer and Scale Modeller</title>
    <link>//bulimov.me/tags/chef/</link>
    <description>Recent content in Chef on Alexander Bulimov: Production Engineer and Scale Modeller</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 29 Sep 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="//bulimov.me/tags/chef/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Инфраструктура как код</title>
      <link>//bulimov.me/it/infrastructure-as-a-code/</link>
      <pubDate>Mon, 29 Sep 2014 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/infrastructure-as-a-code/</guid>
      <description>&lt;p&gt;Есть такой тренд сейчас - работать с IT-инфраструктурой как с кодом.&#xA;Хорошо цель этого метода описывается этой цитатой:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;“Enable the reconstruction of the business from nothing but a source code repository, an application data backup, and bare metal resources”&lt;/p&gt;&#xA;&lt;p&gt;&amp;ndash; Jesse Robins&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;Я полностью поддерживаю эту идею, причем именно в этой трактовке.&lt;/p&gt;&#xA;&lt;p&gt;Если говорить про парадигму, которую нам предлагает этот метод, то вот она:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Поддерживать модульную, легко поддающуюся автоматизации инфраструктуру,&#xA;и &lt;em&gt;описывать&lt;/em&gt; эту инфраструктуру с помощью языка высокого уровня.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Как я управляю серверами</title>
      <link>//bulimov.me/it/%D0%9A%D0%B0%D0%BA-%D1%8F-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0%D0%BC%D0%B8/</link>
      <pubDate>Thu, 05 Sep 2013 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/%D0%9A%D0%B0%D0%BA-%D1%8F-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0%D0%BC%D0%B8/</guid>
      <description>&lt;p&gt;Решил вот описать принципы управления серверами, к которым пришел за эти 3 года.&lt;/p&gt;&#xA;&lt;p&gt;Итак:&lt;/p&gt;&#xA;&lt;h3 id=&#34;принцип-1&#34;&gt;принцип №1&lt;/h3&gt;&#xA;&lt;p&gt;Все конфиги лежат в &lt;a href=&#34;http://en.wikipedia.org/wiki/Revision_control&#34;&gt;VCS&lt;/a&gt;, я сейчас использую Git.&#xA;Я думаю, в комментариях принцип не нуждается, необходимость централизованного&#xA;хранения конфигов, а также хранения истории изменений с возможностью отката обсуждалась не раз.&lt;/p&gt;&#xA;&lt;h3 id=&#34;принцип-2&#34;&gt;принцип №2&lt;/h3&gt;&#xA;&lt;p&gt;Все ПО ставится только из пакетов, никаких ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install.&#xA;Если пакета нужной версии нет в репозиториях дистрибутива - ищем готовый пакет, желательно&#xA;от разработчиков, или от солидного стороннего репозитория типа &lt;a href=&#34;http://www.dotdeb.org/&#34;&gt;dotdeb&lt;/a&gt;. Если пакета для ПО нет - собираем пакет сами,&#xA;причем процесс сборки документируется, а все нужное для сборки кладется в VCS.&#xA;Все сторонние пакеты собираются в свой репозиторий, в котором как минимум есть разделение на stable и testing.&#xA;Все пакеты из testing, после проверки на стейджинге, перемещаются в stable.&#xA;Таким образом, мы контролируем установленное ПО средствами дистрибутива, что сильно упрощает жизнь сисадмина.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Мнение о Chef</title>
      <link>//bulimov.me/it/%D0%9C%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE-chef/</link>
      <pubDate>Mon, 17 Jun 2013 00:00:00 +0000</pubDate>
      <guid>//bulimov.me/it/%D0%9C%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE-chef/</guid>
      <description>&lt;p&gt;Я использовал Chef для управления IT-инфраструктурой около полутора лет, начав с&#xA;версии 0.10. Сначала, где-то пол-года, использовал только для управления конфигурациями,&#xA;без развертывания ПО с нуля. Затем, уже на другой работе, автоматизировал управления&#xA;конфигурациями и развертывание с нуля веб-проекта (30+ серверов, Nginx, ruby, Riak, Redis,&#xA;sphinx-search, RabbitMQ и т.п.).&#xA;Это позволило мне составить собственное мнение o достоинствах и недостатках Chef,&#xA;и в этой заметке я свое мнение излагаю.&lt;/p&gt;&#xA;&lt;p&gt;По итогу вышеописанной деятельности я был настолько утомлен&#xA;недостатками Chef, что начал искать ему замену. Был рассмотрен Puppet и набиравший тогда&#xA;популярность Ansible. Для объективного сравнения я реализовал часть из того,&#xA;что уже было сделано для проекта с помощью Chef, с использованием этих двух SCM.&#xA;По итогу, был выбран Ansible из-за невероятной читабельности получившихся playbook-ов,&#xA;хотя Puppet также во многом обошел Chef. Особенно радовала декларативность Ansible и Puppet,&#xA;а вот неопределенность порядка выполнения в Puppet огорчила.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
